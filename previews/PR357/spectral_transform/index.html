<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Spherical harmonic transform · SpeedyWeather.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpeedyWeather.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../how_to_run_speedy/">How to run SpeedyWeather.jl</a></li><li class="is-active"><a class="tocitem" href>Spherical harmonic transform</a><ul class="internal"><li><a class="tocitem" href="#Inspiration"><span>Inspiration</span></a></li><li><a class="tocitem" href="#Spherical-harmonics"><span>Spherical harmonics</span></a></li><li><a class="tocitem" href="#synthesis"><span>Synthesis (spectral to grid)</span></a></li><li><a class="tocitem" href="#analysis"><span>Analysis (grid to spectral)</span></a></li><li><a class="tocitem" href="#Spectral-packing"><span>Spectral packing</span></a></li><li><a class="tocitem" href="#Available-horizontal-resolutions"><span>Available horizontal resolutions</span></a></li><li><a class="tocitem" href="#Effective-grid-resolution"><span>Effective grid resolution</span></a></li><li><a class="tocitem" href="#Derivatives-in-spherical-coordinates"><span>Derivatives in spherical coordinates</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../grids/">Grids</a></li><li><a class="tocitem" href="../barotropic/">Barotropic model</a></li><li><a class="tocitem" href="../shallowwater/">Shallow water model</a></li><li><a class="tocitem" href="../primitiveequation/">Primitive equation model</a></li><li><a class="tocitem" href="../parameterizations/">Parameterizations</a></li><li><a class="tocitem" href="../extending/">Extending SpeedyWeather</a></li><li><a class="tocitem" href="../output/">NetCDF output</a></li><li><a class="tocitem" href="../ringgrids/">Submodule: RingGrids</a></li><li><a class="tocitem" href="../lowertriangularmatrices/">Submodule: LowerTriangularMatrices</a></li><li><a class="tocitem" href="../speedytransforms/">Submodule: SpeedyTransforms</a></li><li><a class="tocitem" href="../conventions/">Style and convention guide</a></li><li><a class="tocitem" href="../development/">Development notes</a></li><li><a class="tocitem" href="../functions/">Function and type index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Spherical harmonic transform</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Spherical harmonic transform</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SpeedyWeather/SpeedyWeather.jl/blob/main/docs/src/spectral_transform.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Spherical-Harmonic-Transform"><a class="docs-heading-anchor" href="#Spherical-Harmonic-Transform">Spherical Harmonic Transform</a><a id="Spherical-Harmonic-Transform-1"></a><a class="docs-heading-anchor-permalink" href="#Spherical-Harmonic-Transform" title="Permalink"></a></h1><p>The following sections outline the implementation of the spherical harmonic transform (in short <em>spectral</em> transform) between the coefficients of the spherical harmonics (the <em>spectral</em> space) and the grid space which can be any of the <a href="../grids/#Implemented-grids">Implemented grids</a> as defined by <a href="../ringgrids/#RingGrids">RingGrids</a>. This includes the classical full <a href="https://confluence.ecmwf.int/display/FCST/Gaussian+grids">Gaussian grid</a>, a regular longitude-latitude grid called the full Clenshaw grid (<a href="../grids/#FullClenshawGrid">FullClenshawGrid</a>), ECMWF&#39;s octahedral Gaussian grid<sup class="footnote-reference"><a id="citeref-Malardel2016" href="#footnote-Malardel2016">[Malardel2016]</a></sup>, and HEALPix grids<sup class="footnote-reference"><a id="citeref-Gorski2004" href="#footnote-Gorski2004">[Gorski2004]</a></sup>. SpeedyWeather.jl&#39;s spectral transform module SpeedyTransforms is grid-flexible and can be used with any of these, see <a href="../grids/#Grids">Grids</a>.</p><div class="admonition is-info"><header class="admonition-header">SpeedyTransforms is a module too!</header><div class="admonition-body"><p>SpeedyTransform is the underlying module that SpeedyWeather imports to transform between spectral and grid-point space, which also implements <a href="#Derivatives-in-spherical-coordinates">Derivatives in spherical coordinates</a>. You can use this module independently of SpeedyWeather for spectral transforms, see <a href="../speedytransforms/#SpeedyTransforms">SpeedyTransforms</a>.</p></div></div><h2 id="Inspiration"><a class="docs-heading-anchor" href="#Inspiration">Inspiration</a><a id="Inspiration-1"></a><a class="docs-heading-anchor-permalink" href="#Inspiration" title="Permalink"></a></h2><p>The spectral transform implemented by SpeedyWeather.jl follows largely Justin Willmert&#39;s <a href="https://github.com/jmert/CMB.jl">CMB.jl</a> and <a href="https://github.com/jmert/SphericalHarmonicTransforms.jl">SphericalHarmonicTransforms.jl</a> package and makes use of <a href="https://github.com/jmert/AssociatedLegendrePolynomials.jl">AssociatedLegendrePolynomials.jl</a> and <a href="https://github.com/JuliaMath/FFTW.jl">FFTW.jl</a> for the Fourier transform. Justin described his work in a Blog series <sup class="footnote-reference"><a id="citeref-Willmert2020" href="#footnote-Willmert2020">[Willmert2020]</a></sup>.</p><h2 id="Spherical-harmonics"><a class="docs-heading-anchor" href="#Spherical-harmonics">Spherical harmonics</a><a id="Spherical-harmonics-1"></a><a class="docs-heading-anchor-permalink" href="#Spherical-harmonics" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Spherical_harmonics">spherical harmonics</a> <span>$Y_{lm}$</span> of degree <span>$l$</span> and order <span>$m$</span> over the longitude <span>$\phi = (0,2\pi)$</span> and colatitudes <span>$\theta = (-\pi/2,\pi/2)$</span>, are</p><p class="math-container">\[Y_{lm}(\phi, \theta) = \lambda_l^m(\sin\theta) e^{im\phi}\]</p><p>with <span>$\lambda_l^m$</span> being the pre-normalized associated Legendre polynomials, and <span>$e^{im\phi}$</span> are the complex exponentials (the Fourier modes). Together they form a set of orthogonal basis functions on the sphere. For an interactive visualisation of the spherical harmonics, see <a href="https://justinwillmert.com/posts/2020/plots-of-the-spherical-harmonics-eigenmodes/">here</a>.</p><div class="admonition is-info"><header class="admonition-header">Latitudes versus colatitudes</header><div class="admonition-body"><p>The implementation of the spectral transforms in SpeedyWeather.jl uses colatitudes <span>$\theta = (0,\pi)$</span> (0 at the north pole) but the dynamical core uses latitudes <span>$\theta = (-\pi/2,\pi/2)$</span> (<span>$\pi/2$</span> at the north pole). Note: We may also use latitudes in the spherical harmonic transform in the future for consistency. </p></div></div><h2 id="synthesis"><a class="docs-heading-anchor" href="#synthesis">Synthesis (spectral to grid)</a><a id="synthesis-1"></a><a class="docs-heading-anchor-permalink" href="#synthesis" title="Permalink"></a></h2><p>The synthesis (or inverse transform) takes the spectral coefficients <span>$a_{lm}$</span> and transforms them to grid-point values <span>$f(\phi,\theta)$</span> (for the sake of simplicity first regarded as continuous). The synthesis is a linear combination of the spherical harmonics <span>$Y_{lm}$</span> with non-zero coefficients.</p><p class="math-container">\[f(\phi,\theta) = \sum_{l=0}^{\infty} \sum_{m=-l}^l a_{lm} Y_{lm}(\phi,\theta)\]</p><p>We obtain an approximation with a finite set of <span>$a_{l,m}$</span> by truncating the series in both degree <span>$l$</span> and order <span>$m$</span> somehow. Most commonly, a triangular truncation is applied, such that all degrees after <span>$l = l_{max}$</span> are discarded. Triangular because the retained array of the coefficients <span>$a_{l,m}$</span> looks like a triangle. Other truncations like rhomboidal have been studied<sup class="footnote-reference"><a id="citeref-Daley78" href="#footnote-Daley78">[Daley78]</a></sup> but are rarely used since. Choosing <span>$l_{max}$</span> also constrains <span>$m_{max}$</span> and determines the (horizontal) spectral resolution. In SpeedyWeather.jl this resolution as chosen as <code>trunc</code> when creating the <a href="../how_to_run_speedy/#SpectralGrid">SpectralGrid</a>.</p><p>For <span>$f$</span> being a real-valued there is a symmetry</p><p class="math-container">\[a_{l,-m} = (-1)^m a^*_{l,+m},\]</p><p>meaning that the coefficients at <span>$-m$</span> and <span>$m$</span> are the same, but the sign of the real and imaginary component can be flipped, as denoted with the <span>$(-1)^m$</span> and the complex conjugate <span>$a_{l,m}^*$</span>. As we are only dealing with real-valued fields anyway, we therefore never have to store the negative orders <span>$-m$</span> and end up with a lower triangular matrix of size <span>$(l_{max}+1) \times (m_{max}+1)$</span> or technically <span>$(T+1)^2$</span> where <span>$T$</span> is the truncation <code>trunc</code>. One is added here because the degree <span>$l$</span> and order <span>$m$</span> use 0-based indexing but sizes (and so is Julia&#39;s indexing) are 1-based.</p><p>For correctness we want to mention here that vector quantities require one more degree <span>$l$</span> due to the recurrence relation in the <a href="#Meridional-derivative">Meridional derivative</a>. Hence for practical reasons <em>all</em> spectral fields are represented as a lower triangular matrix of size <span>$(m_{max} + 2) \times (m_{max} +1)$</span>. And the scalar quantities would just not make use of that last degree, and its entries would be simply zero. We will, however, for the following sections ignore this and only discuss it again in <a href="#Meridional-derivative">Meridional derivative</a>.</p><p>Another consequence of the symmetry mentioned above is that the zonal harmonics, meaning <span>$a_{l,m=0}$</span> have no imaginary component. Because these harmonics are zonally constant, a non-zero imaginary component would rotate them around the Earth&#39;s axis, which, well, doesn&#39;t actually change a real-valued field. </p><p>Following the notation of <sup class="footnote-reference"><a id="citeref-Willmert2020" href="#footnote-Willmert2020">[Willmert2020]</a></sup> we can therefore write the truncated synthesis as</p><p class="math-container">\[f(\phi,\theta) = \sum_{l=0}^{l_{max}} \sum_{m=0}^l (2-\delta_{m0}) a_{lm} Y_{lm}(\phi,\theta)\]</p><p>The <span>$(2-\delta_{m0})$</span> factor using the Kronecker <span>$\delta$</span> is used here because of the symmetry we have to count both the <span>$m,-m$</span> order pairs (hence the <span>$2$</span>) except for the zonal harmonics which do not have a pair.</p><p>Another symmetry arises from the fact that the spherical harmonics are either symmetric or anti-symmetric around the Equator. There is an even/odd combination of degrees and orders so that the sign flips like a checkerboard</p><p class="math-container">\[Y_{l,m}(\phi,\pi-\theta) = (-1)^{l+m}Y_{lm}(\phi,\phi)\]</p><p>This means that one only has to compute the Legendre polynomials for one hemisphere and the other one follows with this equality.</p><h2 id="analysis"><a class="docs-heading-anchor" href="#analysis">Analysis (grid to spectral)</a><a id="analysis-1"></a><a class="docs-heading-anchor-permalink" href="#analysis" title="Permalink"></a></h2><p>Starting in grid-point space we can transform a field <span>$f(\lambda,\theta)$</span> into the spectral space of the spherical harmonics by</p><p class="math-container">\[a_{l,m} = \int_0^{2\pi} \int_{0}^\pi f(\phi,\theta) Y_{l,m}(\phi,\theta) \sin \theta d\theta d\phi\]</p><p>Note that this notation again uses colatitudes <span>$\theta$</span>, for latitudes the <span>$\sin\theta$</span> becomes a <span>$\cos\theta$</span> and the bounds have to be changed accordingly to <span>$(-\frac{\pi}{2},\frac{\pi}{2})$</span>. A discretization with <span>$N$</span> grid points at location <span>$(\phi_i,\theta_i)$</span>, indexed by <span>$i$</span> can be written as <sup class="footnote-reference"><a id="citeref-Willmert2020" href="#footnote-Willmert2020">[Willmert2020]</a></sup></p><p class="math-container">\[\hat{a}_{l,m} = \sum_i f(\phi_i,\theta_i) Y_{l,m}(\phi_i,\theta_i) \sin \theta_i \Delta\theta \Delta\phi\]</p><p>The hat on <span>$a$</span> just means that it is an approximation, or an estimate of the true <span>$a_{lm} \approx \hat{a}_{lm}$</span>. We can essentially make use of the same symmetries as already discussed in <a href="#synthesis">Synthesis</a>. Splitting into the Fourier modes <span>$e^{im\phi}$</span> and the Legendre polynomials <span>$\lambda_l^m(\cos\theta)$</span> (which are defined over <span>$[-1,1]$</span> so the <span>$\cos\theta$</span> argument maps them to colatitudes) we have</p><p class="math-container">\[\hat{a}_{l,m} = \sum_j \left[ \sum_i f(\phi_i,\theta_j) e^{-im\phi_i} \right] \lambda_{l,m}(\theta_j) \sin \theta_j \Delta\theta \Delta\phi\]</p><p>So the term in brackets can be separated out as long as the latitude <span>$\theta_j$</span> is constant, which motivates us to restrict the spectral transform to grids with iso-latitude rings, see <a href="../grids/#Grids">Grids</a>. Furthermore, this term can be written as a fast Fourier transform, if the <span>$\phi_i$</span> are equally spaced on the latitude ring <span>$j$</span>. Note that the in-ring index <span>$i$</span> can depend on the ring index <span>$j$</span>, so that one can have reduced grids, which have fewer grid points towards the poles, for example. Also the Legendre polynomials only have to be computed for the colatitudes <span>$\theta_j$</span> (and in fact only one hemisphere, due to the north-south symmetry discussed in the <a href="#synthesis">Synthesis</a>). It is therefore practical and efficient to design a spectral transform implementation for ring grids, but there is no need to hardcode a specific grid.</p><h2 id="Spectral-packing"><a class="docs-heading-anchor" href="#Spectral-packing">Spectral packing</a><a id="Spectral-packing-1"></a><a class="docs-heading-anchor-permalink" href="#Spectral-packing" title="Permalink"></a></h2><p>Spectral packing is the way how the coefficients <span>$a_{lm}$</span> of the spherical harmonics of a given spectral field are stored in an array. SpeedyWeather.jl uses the conventional spectral packing of degree <span>$l$</span> and order <span>$m$</span> as illustrated in the following image <a href="https://commons.wikimedia.org/wiki/File:Rotating_spherical_harmonics.gif">(Cyp, CC BY-SA 3.0, via Wikimedia Commons)</a></p><img src="https://upload.wikimedia.org/wikipedia/commons/1/12/Rotating_spherical_harmonics.gif"><p>Every row represents an order <span>$l \geq 0$</span>, starting from <span>$l=0$</span> at the top. Every column represents an order <span>$m \geq 0$</span>, starting from <span>$m=0$</span> on the left. The coefficients of these spherical harmonics are directly mapped into a matrix <span>$a_{lm}$</span> as </p><table><tr><th style="text-align: center"></th><th style="text-align: center"><span>$m$</span></th><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th></tr><tr><td style="text-align: center"><span>$l$</span></td><td style="text-align: center"><span>$a_{00}$</span></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr><tr><td style="text-align: center"></td><td style="text-align: center"><span>$a_{10}$</span></td><td style="text-align: center"><span>$a_{11}$</span></td><td style="text-align: center"></td><td style="text-align: center"></td></tr><tr><td style="text-align: center"></td><td style="text-align: center"><span>$a_{20}$</span></td><td style="text-align: center"><span>$a_{12}$</span></td><td style="text-align: center"><span>$a_{22}$</span></td><td style="text-align: center"></td></tr><tr><td style="text-align: center"></td><td style="text-align: center"><span>$a_{30}$</span></td><td style="text-align: center"><span>$a_{13}$</span></td><td style="text-align: center"><span>$a_{23}$</span></td><td style="text-align: center"><span>$a_{33}$</span></td></tr></table><p>which is consistently extended for higher degrees and orders. Consequently, all spectral fields are lower-triangular matrices with complex entries. The upper triangle excluding the diagonal are zero. Note that internally vector fields include an additional degree, such that <span>$l_{max} = m_{max} + 1$</span> (see <a href="#Derivatives-in-spherical-coordinates">Derivatives in spherical coordinates</a> for more information). The harmonics with <span>$a_{l0}$</span> (the first column) are also called <em>zonal</em> harmonics as they are constant with longitude <span>$\phi$</span>. The harmonics with <span>$a_{ll}$</span> (the main diagonal) are also called <em>sectoral</em> harmonics as they essentially split the sphere into <span>$2l$</span> sectors in longitude <span>$\phi$</span> without a zero-crossing in latitude.</p><p>For correctness it is mentioned here that SpeedyWeather.jl uses a <code>LowerTriangularMatrix</code> type to store the spherical harmonic coefficients. By doing so, the upper triangle is actually <em>not</em> explicitly stored and the data technically unravelled into a vector, but this is hidden as much as possible from the user. For more details see <a href="../lowertriangularmatrices/#lowertriangularmatrices"><code>LowerTriangularMatrices</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Array indices</header><div class="admonition-body"><p>For a spectral field <code>a</code> note that due to Julia&#39;s 1-based indexing the coefficient <span>$a_{lm}$</span> is obtained via <code>a[l+1,m+1]</code>. Alternatively, we may index over 1-based <code>l</code>,<code>m</code> but a comment is usually added for clarification.</p></div></div><p><a href="https://users.ictp.it/~kucharsk/speedy-net.html">Fortran SPEEDY</a> does not use the same spectral packing as SpeedyWeather.jl. The alternative packing <span>$l&#39;,m&#39;$</span> therein uses <span>$l&#39;=m$</span> and <span>$m&#39;=l-m$</span> as summarized in the following table.</p><table><tr><th style="text-align: center">degree <span>$l$</span></th><th style="text-align: center">order <span>$m$</span></th><th style="text-align: center"><span>$l&#39;=m$</span></th><th style="text-align: center"><span>$m&#39;=l-m$</span></th></tr><tr><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">0</td></tr><tr><td style="text-align: center">1</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">1</td></tr><tr><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">0</td></tr><tr><td style="text-align: center">2</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">2</td></tr><tr><td style="text-align: center">2</td><td style="text-align: center">1</td><td style="text-align: center">1</td><td style="text-align: center">1</td></tr><tr><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">2</td><td style="text-align: center">0</td></tr><tr><td style="text-align: center">3</td><td style="text-align: center">0</td><td style="text-align: center">0</td><td style="text-align: center">3</td></tr><tr><td style="text-align: center">...</td><td style="text-align: center">...</td><td style="text-align: center">...</td><td style="text-align: center">...</td></tr></table><p>This alternative packing uses the top-left triangle of a coefficient matrix, and the degrees and orders from above are stored at the following indices</p><table><tr><th style="text-align: center"></th><th style="text-align: center"><span>$m&#39;$</span></th><th style="text-align: center"></th><th style="text-align: center"></th><th style="text-align: center"></th></tr><tr><td style="text-align: center"><span>$l&#39;$</span></td><td style="text-align: center"><span>$a_{00}$</span></td><td style="text-align: center"><span>$a_{10}$</span></td><td style="text-align: center"><span>$a_{20}$</span></td><td style="text-align: center"><span>$a_{30}$</span></td></tr><tr><td style="text-align: center"></td><td style="text-align: center"><span>$a_{11}$</span></td><td style="text-align: center"><span>$a_{21}$</span></td><td style="text-align: center"><span>$a_{31}$</span></td><td style="text-align: center"></td></tr><tr><td style="text-align: center"></td><td style="text-align: center"><span>$a_{22}$</span></td><td style="text-align: center"><span>$a_{32}$</span></td><td style="text-align: center"></td><td style="text-align: center"></td></tr><tr><td style="text-align: center"></td><td style="text-align: center"><span>$a_{33}$</span></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td></tr></table><p>This spectral packing is not used in SpeedyWeather.jl but illustrated here for completeness and comparison with Fortran SPEEDY.</p><p>SpeedyWeather.jl uses triangular truncation such that only spherical harmonics with <span>$l \leq l_{max}$</span> and <span>$|m| \leq m_{max}$</span> are explicitly represented. This is usually described as <span>$Tm_{max}$</span>, with <span>$l_{max} = m_{max}$</span> (although in vector quantities require one more degree <span>$l$</span> in the recursion relation of meridional gradients). For example, T31 is the spectral resolution with <span>$l_{max} = m_{max} = 31$</span>. Note that the degree <span>$l$</span> and order <span>$m$</span> are mathematically 0-based, such that the corresponding coefficient matrix is of size 32x32.</p><h2 id="Available-horizontal-resolutions"><a class="docs-heading-anchor" href="#Available-horizontal-resolutions">Available horizontal resolutions</a><a id="Available-horizontal-resolutions-1"></a><a class="docs-heading-anchor-permalink" href="#Available-horizontal-resolutions" title="Permalink"></a></h2><p>Technically, SpeedyWeather.jl supports arbitrarily chosen resolution parameter <code>trunc</code> when creating the <a href="../how_to_run_speedy/#SpectralGrid">SpectralGrid</a> that refers to the highest non-zero degree <span>$l_{max}$</span> that is resolved in spectral space. SpeedyWeather.jl will always try to choose an easily-Fourier transformable<sup class="footnote-reference"><a id="citeref-FFT" href="#footnote-FFT">[FFT]</a></sup> size of the grid, but as we use <a href="https://github.com/JuliaMath/FFTW.jl">FFTW.jl</a> there is quite some flexibility without performance sacrifice. However, this has traditionally lead to typical resolutions that we also use for testing we therefore recommend to use. They are as follows with more details below</p><table><tr><th style="text-align: right"><code>trunc</code></th><th style="text-align: right">nlon</th><th style="text-align: right">nlat</th><th style="text-align: right"><span>$\Delta x$</span></th></tr><tr><td style="text-align: right">31 (default)</td><td style="text-align: right">96</td><td style="text-align: right">48</td><td style="text-align: right">400 km</td></tr><tr><td style="text-align: right">42</td><td style="text-align: right">128</td><td style="text-align: right">64</td><td style="text-align: right">312 km</td></tr><tr><td style="text-align: right">63</td><td style="text-align: right">192</td><td style="text-align: right">96</td><td style="text-align: right">216 km</td></tr><tr><td style="text-align: right">85</td><td style="text-align: right">256</td><td style="text-align: right">128</td><td style="text-align: right">165 km</td></tr><tr><td style="text-align: right">127</td><td style="text-align: right">384</td><td style="text-align: right">192</td><td style="text-align: right">112 km</td></tr><tr><td style="text-align: right">170</td><td style="text-align: right">512</td><td style="text-align: right">256</td><td style="text-align: right">85 km</td></tr><tr><td style="text-align: right">255</td><td style="text-align: right">768</td><td style="text-align: right">384</td><td style="text-align: right">58 km</td></tr><tr><td style="text-align: right">341</td><td style="text-align: right">1024</td><td style="text-align: right">512</td><td style="text-align: right">43 km</td></tr><tr><td style="text-align: right">511</td><td style="text-align: right">1536</td><td style="text-align: right">768</td><td style="text-align: right">29 km</td></tr><tr><td style="text-align: right">682</td><td style="text-align: right">2048</td><td style="text-align: right">1024</td><td style="text-align: right">22 km</td></tr><tr><td style="text-align: right">1024</td><td style="text-align: right">3072</td><td style="text-align: right">1536</td><td style="text-align: right">14 km</td></tr><tr><td style="text-align: right">1365</td><td style="text-align: right">4092</td><td style="text-align: right">2048</td><td style="text-align: right">11 km</td></tr></table><p>Some remarks on this table</p><ul><li>This assumes the default quadratic truncation, you can always adapt the grid resolution via the <code>dealiasing</code> option, see <a href="../grids/#Matching-spectral-and-grid-resolution">Matching spectral and grid resolution</a></li><li><code>nlat</code> refers to the total number of latitude rings, see <a href="../grids/#Grids">Grids</a>. With non-Gaussian grids, <code>nlat</code> will be one one less, e.g. 47 instead of 48 rings.</li><li><code>nlon</code> is the number of longitude points on the <a href="../grids/#FullGaussianGrid">Full Gaussian Grid</a>, for other grids there will be at most these number of points around the Equator.</li><li><span>$\Delta x$</span> is the horizontal resolution. For a spectral model there are many ways of estimating this<sup class="footnote-reference"><a id="citeref-9" href="#footnote-9">[9]</a></sup>. We use here the square root of the average area a grid cell covers, see <a href="#Effective-grid-resolution">Effective grid resolution</a></li></ul><h2 id="Effective-grid-resolution"><a class="docs-heading-anchor" href="#Effective-grid-resolution">Effective grid resolution</a><a id="Effective-grid-resolution-1"></a><a class="docs-heading-anchor-permalink" href="#Effective-grid-resolution" title="Permalink"></a></h2><p>There are many ways to estimate the effective grid resolution of spectral models<sup class="footnote-reference"><a id="citeref-9" href="#footnote-9">[9]</a></sup>. Some of them are based on the wavelength a given spectral resolution allows to represent, others on the total number of real variables per area. However, as many atmospheric models do represent a considerable amount of physics on the grid (see <a href="../parameterizations/#parameterizations">Parameterizations</a>) there is also a good argument to include the actual grid resolution into this estimate and not just the spectral resolution. We therefore use the average grid cell area to estimate the resolution</p><p class="math-container">\[\Delta x = \sqrt{\frac{4\pi R^2}{N}}\]</p><p>with <span>$N$</span> number of grid points over a sphere with radius <span>$R$</span>. However, we have to acknowledge that this usually gives higher resolution compared to other methods of estimating the effective resolution, see <sup class="footnote-reference"><a id="citeref-Randall2021" href="#footnote-Randall2021">[Randall2021]</a></sup> for a discussion. You may therefore need to be careful to make claims that, e.g. <code>trunc=85</code> can resolve the atmospheric dynamics at a scale of 165km.</p><h2 id="Derivatives-in-spherical-coordinates"><a class="docs-heading-anchor" href="#Derivatives-in-spherical-coordinates">Derivatives in spherical coordinates</a><a id="Derivatives-in-spherical-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives-in-spherical-coordinates" title="Permalink"></a></h2><p>Horizontal gradients in spherical coordinates are defined for a scalar field <span>$A$</span> and the latitudes <span>$\theta$</span> and longitudes <span>$\lambda$</span> as</p><p class="math-container">\[\nabla A = \left(\frac{1}{R\cos\theta}\frac{\partial A}{\partial \lambda}, \frac{1}{R}\frac{\partial A}{\partial \theta} \right).\]</p><p>However, the divergence of a vector field <span>$\mathbf{u} = (u,v)$</span> includes additional <span>$\cos(\theta)$</span> scalings</p><p class="math-container">\[\nabla \cdot \mathbf{u} = \frac{1}{R\cos\theta}\frac{\partial u}{\partial \lambda} +
\frac{1}{R\cos\theta}\frac{\partial (v \cos\theta)}{\partial \theta},\]</p><p>and similar for the curl</p><p class="math-container">\[\nabla \times \mathbf{u} = \frac{1}{R\cos\theta}\frac{\partial v}{\partial \lambda} -
\frac{1}{R\cos\theta}\frac{\partial (u \cos\theta)}{\partial \theta}.\]</p><p>The radius of the sphere (i.e. Earth) is <span>$R$</span>. The zonal gradient scales with <span>$1/\cos(\theta)$</span> as the  longitudes converge towards the poles (note that <span>$\theta$</span> describes latitudes here, definitions using colatitudes replace the <span>$\cos$</span> with a <span>$\sin$</span>.)</p><p>Starting with a spectral field of vorticity <span>$\zeta$</span> and divergence <span>$\mathcal{D}$</span> one can obtain stream function <span>$\Psi$</span> and velocity potential <span>$\Phi$</span> by inverting the Laplace operator <span>$\nabla^2$</span>:</p><p class="math-container">\[\Psi = \nabla^{-2}\zeta, \quad \Phi = \nabla^{-2}\mathcal{D}.\]</p><p>The velocities <span>$u,v$</span> are then obtained from <span>$(u,v) = \nabla^\bot\Psi + \nabla\Phi$</span> following the definition from above and <span>$\nabla^\bot = (-R^{-1}\partial_\theta, (R\cos\theta)^{-1}\partial_\lambda)$</span></p><p class="math-container">\[\begin{aligned}
u &amp;= -\frac{1}{R}\partial_\theta\Psi + \frac{1}{R\cos\theta}\partial_\lambda\Phi \\
v &amp;= +\frac{1}{R}\partial_\theta\Phi + \frac{1}{R\cos\theta}\partial_\lambda\Psi.
\end{aligned}\]</p><p>Alternatively, we can use the velocities <span>$U = u\cos\theta, V = v\cos\theta$</span>, which we do as the meridional gradient for spherical harmonics is easier implemented with a <span>$\cos\theta$</span>-scaling included, and because the divergence and  curl in spherical coordinates evaluates the meridional gradient with <span>$U,V$</span> and not <span>$u,v$</span>. From <span>$u,v$</span> we can return to <span>$\zeta, \mathcal{D}$</span> via</p><p class="math-container">\[\begin{aligned}
\zeta &amp;= \frac{1}{R\cos\theta}\partial_\lambda v - \frac{1}{R\cos\theta}\partial_\theta (u \cos\theta) \\
\mathcal{D} &amp;= \frac{1}{R\cos\theta}\partial_\lambda u + \frac{1}{R\cos\theta}\partial_\theta (v \cos\theta).
\end{aligned}\]</p><p>Equivalently, we have</p><p class="math-container">\[\begin{aligned}
U &amp;= -\frac{\cos\theta}{R}\partial_\theta\Psi + \frac{1}{R}\partial_\lambda\Phi \\
V &amp;= +\frac{\cos\theta}{R}\partial_\theta\Phi + \frac{1}{R}\partial_\lambda\Psi \\
\zeta &amp;= \frac{1}{R}\partial_\lambda \left( \frac{V}{\cos^2\theta} \right) -
\frac{\cos\theta}{R}\partial_\theta \left( \frac{U}{\cos^2\theta} \right) \\
\mathcal{D} &amp;= \frac{1}{R}\partial_\lambda \left( \frac{U}{\cos^2\theta} \right) +
\frac{\cos\theta}{R}\partial_\theta \left( \frac{V}{\cos^2\theta} \right).
\end{aligned}\]</p><p>which is a more convenient formulation because of the way how the <a href="#Meridional-derivative">Meridional derivative</a> is implemented with a recursion relation, actually computing <span>$\cos\theta \partial_\theta$</span> rather than <span>$\partial_\theta$</span> directly. The remaining cosine scalings in <span>$(U,V)*\cos^{-2}\theta$</span> are done in grid-point space. If one wanted to get back to <span>$\zeta, \mathcal{D}$</span> this is how it would be done, but it is often more convenient to unscale <span>$U,V$</span> on the fly in the spectral transform to obtain <span>$u,v$</span> and then divide again by <span>$\cos\theta$</span> when any gradient (or divergence or curl) is taken. This is because other terms would need that single <span>$\cos\theta$</span> unscaling too before a gradient is taken. How the operators <span>$\nabla, \nabla \times, \nabla \cdot$</span> can be implemented with spherical harmonics is presented in the following sections.</p><p>Also note that SpeedyWeather.jl scales the equations with the radius <code>R</code> (see <a href="../barotropic/#scaling">Radius scaling</a>) such that the divisions by <code>R</code> drop out in this last formulation too.</p><h3 id="Zonal-derivative"><a class="docs-heading-anchor" href="#Zonal-derivative">Zonal derivative</a><a id="Zonal-derivative-1"></a><a class="docs-heading-anchor-permalink" href="#Zonal-derivative" title="Permalink"></a></h3><p>The zonal derivative of a scalar field <span>$\Psi$</span> in spectral space is the zonal derivative of all its respective spherical harmonics <span>$\Psi_{lm}(\phi,\theta)$</span> (now we use <span>$\phi$</span> for longitudes to avoid confusion with the Legendre polynomials <span>$\lambda_{lm}$</span>)</p><p class="math-container">\[v_{lm} = \frac{1}{R \cos(\theta)} \frac{\partial}{\partial \phi} \left( \lambda_l^m(\cos\theta) e^{im\phi} \right) =
\frac{im}{R \cos(\theta)} \lambda_l^m(\cos\theta) e^{im\phi} = \frac{im}{R \cos(\theta)} \Psi_{lm}\]</p><p>So for every spectral harmonic, <span>$\cos(\theta)v_{lm}$</span> is obtained from <span>$\Psi_{lm}$</span> via a multiplication with <span>$im/R$</span>. Unscaling the <span>$\cos(\theta)$</span>-factor is done after transforming the spectral coefficients <span>$v_{lm}$</span> into grid-point space. As discussed in <a href="../barotropic/#scaling">Radius scaling</a>, SpeedyWeather.jl scales the stream function as <span>$\tilde{\Psi} = R^{-1}\Psi$</span> such that the division by radius <span>$R$</span> in the gradients can be omitted. The zonal derivative becomes therefore effectively for each spherical harmonic a scaling with its (imaginary) order <span>$im$</span>. The spherical harmonics are essentially just a Fourier transform in zonal direction and the derivative a multiplication with the respective wave number <span>$m$</span> times imaginary <span>$i$</span>.</p><h3 id="Meridional-derivative"><a class="docs-heading-anchor" href="#Meridional-derivative">Meridional derivative</a><a id="Meridional-derivative-1"></a><a class="docs-heading-anchor-permalink" href="#Meridional-derivative" title="Permalink"></a></h3><p>The meridional derivative of the spherical harmonics is a derivative of the Legendre polynomials for which the following recursion relation applies<sup class="footnote-reference"><a id="citeref-10" href="#footnote-10">[10]</a></sup>,<sup class="footnote-reference"><a id="citeref-11" href="#footnote-11">[11]</a></sup></p><p class="math-container">\[\cos\theta \frac{dP_{l,m}}{d\theta} = -l\epsilon_{l+1,m}P_{l+1,m} + (l+1)\epsilon_{l,m}P_{l-1,m}.\]</p><p>with recursion factors</p><p class="math-container">\[\epsilon_{l,m} = \sqrt{\frac{l^2-m^2}{4l^2-1}}\]</p><p>In the following we use the example of obtaining the zonal velocity <span>$u$</span> from the stream function <span>$\Psi$</span>, which is through the negative meridional gradient. For the meridional derivative itself the leading minus sign has to be omitted. Starting with the spectral expansion</p><p class="math-container">\[\Psi(\lambda,\theta) = \sum_{l,m}\Psi_{l,m}P_{l,m}(\sin\theta)e^{im\lambda}\]</p><p>we multiply with <span>$-R^{-1}\cos\theta\partial_\theta$</span> to obtain</p><p class="math-container">\[\cos\theta\left(-\frac{1}{R}\partial_\theta\Psi \right) = -\frac{1}{R}\sum_{l,m}\Psi_{l,m}e^{im\lambda}\cos\theta\partial_\theta P_{l,m}\]</p><p>at which point the recursion from above can be applied. Collecting terms proportional to <span>$P_{l,m}$</span> then yields</p><p class="math-container">\[(\cos(\theta)u)_{l,m} = -\frac{1}{R}(-(l-1)\epsilon_{l,m}\Psi_{l-1,m} + (l+2)\epsilon_{l+1,m}\Psi_{l+1,m})\]</p><p>To obtain the coefficient of each spherical harmonic <span>$l,m$</span> of the meridional gradient of a spectral field, two  coefficients at <span>$l-1,m$</span> and <span>$l+1,m$</span> have to be combined. This means that the coefficient of a gradient <span>$((\cos\theta) u)_{lm}$</span> is a linear combination of the coefficients of one higher and one lower degree <span>$\Psi_{l+1,m},\Psi_{l-1,m}$</span>. As the coefficient <span>$\Psi_{lm}$</span> with <span>$m&lt;l$</span> are zero, the sectoral harmonics (<span>$l=m$</span>) of the gradients are obtained from the first off-diagonal only. However, the <span>$l=l_{max}$</span> harmonics of the gradients require the <span>$l_{max}-1$</span> as well as the <span>$l_{max}+1$</span> harmonics. As a consequence vector quantities like velocity components <span>$u,v$</span> require one more degree <span>$l$</span> than scalar quantities like vorticity<sup class="footnote-reference"><a id="citeref-Bourke72" href="#footnote-Bourke72">[Bourke72]</a></sup>. However, for easier compatibility all spectral fields in SpeedyWeather.jl use one more degree <span>$l$</span>, but scalar quantities should not make use of it. Equivalently, the last degree <span>$l$</span> is  set to zero before the time integration, which only advances scalar quantities.</p><p>In SpeedyWeather.jl vector quantities like <span>$u,v$</span> use therefore one more meridional mode than scalar quantities such as vorticity <span>$\zeta$</span> or stream function <span>$\Psi$</span>. The meridional derivative in SpeedyWeather.jl also omits the <span>$1/R$</span>-scaling as explained for the <a href="#Zonal-derivative">Zonal derivative</a> and in <a href="../barotropic/#scaling">Radius scaling</a>.</p><h3 id="Divergence-and-curl-in-spherical-harmonics"><a class="docs-heading-anchor" href="#Divergence-and-curl-in-spherical-harmonics">Divergence and curl in spherical harmonics</a><a id="Divergence-and-curl-in-spherical-harmonics-1"></a><a class="docs-heading-anchor-permalink" href="#Divergence-and-curl-in-spherical-harmonics" title="Permalink"></a></h3><p>The meridional gradient as described above can be applied to scalars, such as <span>$\Psi$</span> and <span>$\Phi$</span> in the conversion to velocities <span>$(u,v) = \nabla^\bot\Psi + \nabla\Phi$</span>, however, the operators curl <span>$\nabla \times$</span> and divergence <span>$\nabla \cdot$</span> in spherical coordinates involve a <span>$\cos\theta$</span> scaling <em>before</em> the meridional gradient is applied. How to translate this to spectral coefficients has to be derived separately<sup class="footnote-reference"><a id="citeref-10" href="#footnote-10">[10]</a></sup>,<sup class="footnote-reference"><a id="citeref-11" href="#footnote-11">[11]</a></sup>.</p><p>The spectral transform of vorticity <span>$\zeta$</span> is</p><p class="math-container">\[\zeta_{l,m} = \frac{1}{2\pi}\int_{-\tfrac{\pi}{2}}^\tfrac{\pi}{2}\int_0^{2\pi} \zeta(\lambda,\theta)
P_{l,m}(\sin\theta) e^{im\lambda} d\lambda \cos\theta d\theta\]</p><p>Given that <span>$R\zeta = \cos^{-1}\partial_\lambda v - \cos^{-1}\partial_\theta (u \cos\theta)$</span>, we therefore have to evaluate a meridional integral of the form</p><p class="math-container">\[\int P_{l,m} \frac{1}{\cos \theta} \partial_\theta(u \cos\theta)) \cos \theta d\theta\]</p><p>which can be solved through integration by parts. As <span>$u\cos\theta = 0$</span> at <span>$\theta = \pm \tfrac{\pi}{2}$</span> only the integral</p><p class="math-container">\[= -\int \partial_\theta P_{l,m} (u \cos\theta) d\theta = -\int \cos\theta \partial_\theta P_{l,m}
(\frac{u}{\cos\theta}) \cos\theta d\theta\]</p><p>remains. Inserting the recurrence relation from the <a href="#Meridional-derivative">Meridional derivative</a> turns this into</p><p class="math-container">\[= -\int \left(-l \epsilon_{l+1,m}P_{l+1,m} + (l+1)\epsilon_{l,m} P_{l-1,m} \right) (\frac{u}{\cos\theta})
\cos \theta d\theta\]</p><p>Now we expand <span>$(\tfrac{u}{\cos\theta})$</span> but only the <span>$l,m$</span> harmonic will project onto<span>$P_{l,m}$</span>. Let <span>$u^* = u\cos^{-1}\theta, v^* = v\cos^{-1}\theta$</span> we then have in total</p><p class="math-container">\[\begin{aligned}
R\zeta_{l,m} &amp;= imv^*_{l,m} + (l+1)\epsilon_{l,m}u^*_{l-1,m} - l\epsilon_{l+1,m}u^*_{l+1,m} \\
RD_{l,m} &amp;= imu^*_{l,m} - (l+1)\epsilon_{l,m}v^*_{l-1,m} + l\epsilon_{l+1,m}v^*_{l+1,m} \\
\end{aligned}\]</p><p>And the divergence <span>$D$</span> is similar, but <span>$(u,v) \to (-v,u)$</span>. We have moved the scaling with the radius <span>$R$</span> directly into <span>$\zeta,D$</span> as further described in <a href="../barotropic/#scaling">Radius scaling</a>.</p><h3 id="Laplacian"><a class="docs-heading-anchor" href="#Laplacian">Laplacian</a><a id="Laplacian-1"></a><a class="docs-heading-anchor-permalink" href="#Laplacian" title="Permalink"></a></h3><p>The spectral Laplacian is easily applied to the coefficients <span>$\Psi_{lm}$</span> of a spectral field as the spherical harmonics are eigenfunctions of the Laplace operator <span>$\nabla^2$</span> in spherical coordinates with eigenvalues <span>$-l(l+1)$</span> divided by the radius squared <span>$R^2$</span>, i.e. <span>$\nabla^2 \Psi$</span> becomes <span>$\tfrac{-l(l+1)}{R^2}\Psi_{lm}$</span> in spectral space. For example, vorticity <span>$\zeta$</span> and streamfunction <span>$\Psi$</span> are related by <span>$\zeta = \nabla^2\Psi$</span> in the barotropic vorticity model. Hence, in spectral space this is equivalent for every spectral mode of degree <span>$l$</span> and order <span>$m$</span> to</p><p class="math-container">\[\zeta_{l,m} = \frac{-l(l+1)}{R^2}\Psi_{l,m}\]</p><p>This can be easily inverted to obtain the stream function <span>$\Psi$</span> from vorticity <span>$\zeta$</span> instead. In order to avoid division by zero, we set <span>$\Psi_{0,0}$</span> here, given that the stream function is only defined up to a constant anyway.</p><p class="math-container">\[\begin{aligned}
\Psi_{l,m} &amp;= \frac{R^2}{-l(l+1)}\zeta_{l,m} \quad \forall~l,m &gt; 0,\\
\Psi_{0,0} &amp;= 0.
\end{aligned}\]</p><p>See also <a href="../barotropic/#diffusion">Horizontal diffusion</a> and <a href="../barotropic/#Normalization-of-diffusion">Normalization of diffusion</a>.</p><h3 id="U,V-from-vorticity-and-divergence"><a class="docs-heading-anchor" href="#U,V-from-vorticity-and-divergence">U,V from vorticity and divergence</a><a id="U,V-from-vorticity-and-divergence-1"></a><a class="docs-heading-anchor-permalink" href="#U,V-from-vorticity-and-divergence" title="Permalink"></a></h3><p>After having discussed the zonal and meridional derivatives with spherical harmonics as well as the Laplace operator, we can derive the conversion from vorticity <span>$\zeta$</span> and divergence <span>$D$</span> (which are prognostic variables) to <span>$U=u\cos\theta, V=v\cos\theta$</span>. Both are linear operations that act either solely on a given harmonic (the zonal gradient and the Laplace operator) or are linear combinations between one lower and one higher degree <span>$l$</span> (the meridional gradient). It is therefore computationally more efficient to compute <span>$U,V$</span> directly from <span>$\zeta,D$</span> instead of calculating stream function and velocity potential first. In total we have</p><p class="math-container">\[\begin{aligned}
U_{l,m} &amp;= -\frac{im}{l(l+1)}(RD)_{l,m} + \frac{\epsilon_{l+1,m}}{l+1}(R\zeta)_{l+1,m} -
\frac{\epsilon_{l,m}}{l}(R\zeta)_{l-1,m} \\
V_{l,m} &amp;= -\frac{im}{l(l+1)}(R\zeta)_{l,m} - \frac{\epsilon_{l+1,m}}{l+1}(RD)_{l+1,m} +
\frac{\epsilon_{l,m}}{l}(RD)_{l-1,m} \\
\end{aligned}\]</p><p>We have moved the scaling with the radius <span>$R$</span> directly into <span>$\zeta,D$</span> as further described in <a href="../barotropic/#scaling">Radius scaling</a>.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Malardel2016"><a class="tag is-link" href="#citeref-Malardel2016">Malardel2016</a>Malardel S, Wedi N, Deconinck W, Diamantakis M, Kühnlein C, Mozdzynski G, Hamrud M, Smolarkiewicz P. A new grid for the IFS. ECMWF newsletter. 2016;146(23-28):321. doi: <a href="https://doi.org/10.21957/zwdu9u5i">10.21957/zwdu9u5i</a></li><li class="footnote" id="footnote-Gorski2004"><a class="tag is-link" href="#citeref-Gorski2004">Gorski2004</a>Górski, Hivon, Banday, Wandelt, Hansen, Reinecke, Bartelmann, 2004. <em>HEALPix: A FRAMEWORK FOR HIGH-RESOLUTION DISCRETIZATION AND FAST ANALYSIS OF DATA DISTRIBUTED ON THE SPHERE</em>, The Astrophysical Journal. doi:<a href="https://doi.org/10.1086/427976">10.1086/427976</a></li><li class="footnote" id="footnote-Willmert2020"><a class="tag is-link" href="#citeref-Willmert2020">Willmert2020</a><p>Justin Willmert, 2020. <a href="https://justinwillmert.com/">justinwillmert.com</a></p><ul><li><a href="https://justinwillmert.com/articles/2020/introduction-to-associated-legendre-polynomials/">Introduction to Associated Legendre Polynomials (Legendre.jl Series, Part I)</a></li><li><a href="https://justinwillmert.com/articles/2020/calculating-legendre-polynomials/">Calculating Legendre Polynomials (Legendre.jl Series, Part II)</a></li><li><a href="https://justinwillmert.com/articles/2020/pre-normalizing-legendre-polynomials/">Pre-normalizing Legendre Polynomials (Legendre.jl Series, Part III)</a></li><li><a href="https://justinwillmert.com/articles/2020/maintaining-numerical-accuracy-in-the-legendre-recurrences/">Maintaining numerical accuracy in the Legendre recurrences (Legendre.jl Series, Part IV)</a></li><li><a href="https://justinwillmert.com/articles/2020/introducing-legendre.jl/">Introducing Legendre.jl (Legendre.jl Series, Part V)</a></li><li><a href="https://justinwillmert.com/posts/2020/pre-normalizing-legendre-polynomials-addendum/">Numerical Accuracy of the Spherical Harmonic Recurrence Coefficient (Legendre.jl Series Addendum)</a></li><li><a href="https://justinwillmert.com/articles/2020/notes-on-calculating-the-spherical-harmonics">Notes on Calculating the Spherical Harmonics</a></li><li><a href="https://justinwillmert.com/articles/2022/more-notes-on-calculating-the-spherical-harmonics/">More Notes on Calculating the Spherical Harmonics: Analysis of maps to harmonic coefficients</a></li></ul></li><li class="footnote" id="footnote-Daley78"><a class="tag is-link" href="#citeref-Daley78">Daley78</a>Roger Daley &amp; Yvon Bourassa (1978) Rhomboidal versus triangular spherical harmonic truncation: Some verification statistics, Atmosphere-Ocean, 16:2, 187-196, DOI: <a href="https://doi.org/10.1080/07055900.1978.9649026">10.1080/07055900.1978.9649026</a></li><li class="footnote" id="footnote-Randall2021"><a class="tag is-link" href="#citeref-Randall2021">Randall2021</a>David Randall, 2021. <a href="http://hogback.atmos.colostate.edu/group/dave/at604pdf/An_Introduction_to_Numerical_Modeling_of_the_Atmosphere.pdf">An Introduction to Numerical Modeling of the Atmosphere</a>, Chapter 22.</li><li class="footnote" id="footnote-Durran2010"><a class="tag is-link" href="#citeref-Durran2010">Durran2010</a>Dale Durran, 2010. <a href="https://link.springer.com/book/10.1007/978-1-4419-6412-0">Numerical Methods for Fluid Dynamics</a>, Springer. In particular section 6.2, 6.4.</li><li class="footnote" id="footnote-GFDL"><a class="tag is-link" href="#citeref-GFDL">GFDL</a>Geophysical Fluid Dynamics Laboratory, <a href="https://www.gfdl.noaa.gov/wp-content/uploads/files/user_files/pjp/barotropic.pdf">The barotropic vorticity equation</a>.</li><li class="footnote" id="footnote-FFT"><a class="tag is-link" href="#citeref-FFT">FFT</a>Depending on the implementation of the Fast Fourier Transform (<a href="https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm">Cooley-Tukey algorithm</a>, or or the <a href="https://en.wikipedia.org/wiki/Chirp_Z-transform#Bluestein.27s_algorithm">Bluestein algorithm</a>) <em>easily Fourier-transformable</em> can mean different things: Vectors of the length <span>$n$</span> that is a power of two, i.e. <span>$n = 2^i$</span> is certainly easily Fourier-transformable, but for most FFT implementations so are <span>$n = 2^i3^j5^k$</span> with <span>$i,j,k$</span> some positive integers. In fact, <a href="http://fftw.org/">FFTW</a> uses <span>$O(n \log n)$</span> algorithms even for prime sizes.</li><li class="footnote" id="footnote-Bourke72"><a class="tag is-link" href="#citeref-Bourke72">Bourke72</a>Bourke, W. An Efficient, One-Level, Primitive-Equation Spectral Model. Mon. Wea. Rev. 100, 683–689 (1972). doi:<a href="https://doi.org/10.1175/1520-0493(1972)100&lt;0683:AEOPSM&gt;2.3.CO;2">10.1175/1520-0493(1972)100&lt;0683:AEOPSM&gt;2.3.CO;2</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../how_to_run_speedy/">« How to run SpeedyWeather.jl</a><a class="docs-footer-nextpage" href="../grids/">Grids »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 16 June 2023 15:39">Friday 16 June 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
