var documenterSearchIndex = {"docs":
[{"location":"development/#Development-notes","page":"Development notes","title":"Development notes","text":"","category":"section"},{"location":"development/","page":"Development notes","title":"Development notes","text":"To run tests, from the path of your local clone of the repository do:","category":"page"},{"location":"development/","page":"Development notes","title":"Development notes","text":"julia --project=. -e 'import Pkg; Pkg.test()'","category":"page"},{"location":"development/","page":"Development notes","title":"Development notes","text":"To install dependencies:","category":"page"},{"location":"development/","page":"Development notes","title":"Development notes","text":"julia --project -e 'import Pkg; Pkg.instantiate()`","category":"page"},{"location":"development/","page":"Development notes","title":"Development notes","text":"then opening:","category":"page"},{"location":"development/","page":"Development notes","title":"Development notes","text":"julia --project","category":"page"},{"location":"development/","page":"Development notes","title":"Development notes","text":"you are able to using SpeedyWeather.","category":"page"},{"location":"development/","page":"Development notes","title":"Development notes","text":"To generate the docs:","category":"page"},{"location":"development/","page":"Development notes","title":"Development notes","text":"julia --project=docs -e 'import Pkg; Pkg.develop(path=\".\"); Pkg.instantiate()'\njulia --project=docs docs/make.jl","category":"page"},{"location":"development/","page":"Development notes","title":"Development notes","text":"If the docs are generated successfully, you view them by opening docs/build/index.html in your favorite browser.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"SpeedyWeather.jl is registered in the Julia Registry. In most cases just open the Julia REPL and type","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> Pkg.add(\"SpeedyWeather\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"which will automatically install the latest release and all necessary dependencies. If you run into any troubles please raise an issue","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"However, you may want to make use of the latest features, then install directly from the main branch with","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> Pkg.add(url=\"https://github.com/SpeedyWeather/SpeedyWeather.jl\",rev=\"main\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"other branches than main can be similarly installed.","category":"page"},{"location":"installation/#Compatibility-with-Julia-versions","page":"Installation","title":"Compatibility with Julia versions","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"SpeedyWeather.jl usually lives on the latest minor release and/or its predecessor. At the moment (May 2023) this means ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia v1.8\nJulia v1.9","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"are supported, but we dropped the support of earlier versions.","category":"page"},{"location":"output/#NetCDF-output","page":"NetCDF output","title":"NetCDF output","text":"","category":"section"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"SpeedyWeather.jl uses NetCDF to output the data of a simulation. The following describes the details of this and how to change the way in which the NetCDF output is written. There are many options to this available.","category":"page"},{"location":"output/#Accessing-the-NetCDF-output-writer","page":"NetCDF output","title":"Accessing the NetCDF output writer","text":"","category":"section"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"The output writer is a component of every Model, i.e. BarotropicModel, ShallowWaterModel, PrimitiveDryModel and PrimitiveWetModel, hence a non-default output writer can be passed on as a keyword argument to the model constructor","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"julia> spectral_grid = SpectralGrid()\njulia> my_output_writer = OutputWriter(spectral_grid, PrimitiveDry)\njulia> model = PrimitiveDryModel(;spectral_grid, output=my_output_writer)","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"So after we have defined the grid through the SpectralGrid object we can use and change the implemented OutputWriter by passing on the following arguments","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"julia> my_output_writer = OutputWriter(spectral_grid, PrimitiveDry, kwargs...)","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"the spectral_grid has to be the first argument then the model type (Barotropic, ShallowWater, PrimitiveDry, PrimitiveWet) which helps the output writer to make default choices on which variables to output. However, we can also pass on further keyword arguments. So let's start with an example.","category":"page"},{"location":"output/#Example-1:-NetCDF-output-every-hour","page":"NetCDF output","title":"Example 1: NetCDF output every hour","text":"","category":"section"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"If we want to increase the frequency of the output we can choose output_dt (default =6 in hours) like so","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"julia> my_output_writer = OutputWriter(spectral_grid, PrimitiveDry, output_dt=1)\njulia> model = PrimitiveDryModel(;spectral_grid, output=my_output_writer)","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"which will now output every hour. It is important to pass on the new output writer my_output_writer to the model constructor, otherwise it will not be part of your model and the default is used instead. Note that output_dt has to be understood as the minimum frequency or maximum output time step. Example, we run the model at a resolution of T85 and the time step is going to be 670s","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"julia> spectral_grid = SpectralGrid(trunc=85)\njulia> time_stepper = Leapfrog(spectral_grid)\nLeapfrog{Float32}:\n...\n Δt_sec::Int64 = 670\n...","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"This means that after 32 time steps 5h 57min and 20s will have passed where output will happen as the next time step would be >6h. The time axis of the NetCDF output will look like","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"julia> using NCDatasets\njulia> ds = NCDataset(\"run_0001/output.nc\");\njulia> ds[\"time\"][:]\n5-element Vector{Dates.DateTime}:\n 2000-01-01T00:00:00\n 2000-01-01T05:57:20\n 2000-01-01T11:54:40\n 2000-01-01T17:52:00\n 2000-01-01T23:49:20\n\njulia> diff(ds[\"time\"][:])\n4-element Vector{Dates.Millisecond}:\n 21440000 milliseconds\n 21440000 milliseconds\n 21440000 milliseconds\n 21440000 milliseconds","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"This is so that we don't interpolate in time during output to hit exactly every 6 hours, but at the same time have a constant spacing in time between output time steps.","category":"page"},{"location":"output/#Example-2:-Output-onto-a-higher/lower-resolution-grid","page":"NetCDF output","title":"Example 2: Output onto a higher/lower resolution grid","text":"","category":"section"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"Say we want to run the model at a given horizontal resolution but want to output on another resolution, the OutputWriter takes as argument output_Grid<:AbstractFullGrid and nlat_half::Int. So for example output_Grid=FullClenshawGrid and nlat_half=48 will always interpolate onto a regular 192x95 longitude-latitude grid of 1.875˚ resolution, regardless the grid and resolution used for the model integration.","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"julia> my_output_writer = OutputWriter(spectral_grid, PrimitiveDry, output_Grid=FullClenshawGrid, nlat_half=48)","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"Note that by default the output is on the corresponding full of the grid used in the dynamical core so that interpolation only happens at most in the zonal direction as they share the location of the latitude rings. You can check this by","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"julia> RingGrids.full_grid(OctahedralGaussianGrid)\nFullGaussianGrid","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"So the corresponding full grid of an OctahedralGaussianGrid is the FullGaussiangrid and the same resolution nlat_half is chosen by default in the output writer (which you can change though as shown above). Overview of the corresponding full grids","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"Grid Corresponding full grid\nFullGaussianGrid FullGaussianGrid\nFullClenshawGrid FullClenshawGrid\nOctahadralGaussianGrid FullGaussianGrid\nOctahedralClensawhGrid FullClenshawGrid\nHEALPixGrid FullHEALPixGrid\nOctaHEALPixGrid FullOctaHEALPixGrid","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"The grids FullHEALPixGrid, FullOctaHEALPixGrid share the same latitude rings as their reduced grids, but have always as many longitude points as they are at most around the equator. These grids are not tested in the dynamical core (but you may use them experimentally) and mostly designed for output purposes.","category":"page"},{"location":"output/#Example-3:-Changing-the-output-path-or-identification","page":"NetCDF output","title":"Example 3: Changing the output path or identification","text":"","category":"section"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"That's easy by passing on path=\"/my/favourite/path/\" and the folder run_* with * the identification of the run (that's the id keyword, which can be manually set but is also automatically determined as a number counting up depending on which folders already exist) will be created within.","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"julia> path = pwd()\n\"/Users/milan\"\njulia> my_output_writer = OutputWriter(spectral_grid, PrimitiveDry, path=path)","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"This folder must already exist. If you want to give your run a name/identification you can pass on id","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"julia> my_output_writer = OutputWriter(spectral_grid,PrimitiveDry,id=\"diffusion_test\");","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"which will be used instead of a 4 digit number like 0001, 0002 which is automatically determined if id is not provided. You will see the id of the run in the progress bar","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"Weather is speedy: run diffusion_test 100%|███████████████████████| Time: 0:00:12 (19.20 years/day)","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"and the run folder, here run_diffusion_test, is also named accordingly","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"shell> ls\n...\nrun_diffusion_test\n...","category":"page"},{"location":"output/#Further-options","page":"NetCDF output","title":"Further options","text":"","category":"section"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"Further options are described in the OutputWriter docstring, (also accessible via julia>?OutputWriter for example). Note that some fields are actual options, but others are derived from the options you provided or are arrays/objects the output writer needs, but shouldn't be passed on by the user. The actual options are declared as [OPTION] in the following","category":"page"},{"location":"output/","page":"NetCDF output","title":"NetCDF output","text":"OutputWriter","category":"page"},{"location":"output/#SpeedyWeather.OutputWriter","page":"NetCDF output","title":"SpeedyWeather.OutputWriter","text":"NetCDF output writer. Contains all output options and auxiliary fields for output interpolation. To be initialised with OutputWriter(::SpectralGrid,::Type{<:ModelSetup},kwargs...) to pass on the resolution information and the model type which chooses which variables to output. Options include\n\nspectral_grid::SpectralGrid\noutput::Bool\npath::String: [OPTION] path to output folder, run_???? will be created within\nid::String: [OPTION] run identification number/string\nrun_path::String\nfilename::String: [OPTION] name of the output netcdf file\nwrite_restart::Bool: [OPTION] also write restart file if output==true?\npkg_version::VersionNumber\nstartdate::Dates.DateTime\noutput_dt::Float64: [OPTION] output frequency, time step [hrs]\noutput_dt_sec::Int64: actual output time step [sec]\noutput_vars::Vector{Symbol}: [OPTION] which variables to output, u, v, vor, div, pres, temp, humid\nmissing_value::Union{Float32, Float64}: [OPTION] missing value to be used in netcdf output\ncompression_level::Int64: [OPTION] lossless compression level; 1=low but fast, 9=high but slow\nkeepbits::SpeedyWeather.Keepbits: [OPTION] mantissa bits to keep for every variable\noutput_every_n_steps::Int64\ntimestep_counter::Int64\noutput_counter::Int64\nnetcdf_file::Union{Nothing, NetCDF.NcFile}\ninput_Grid::Type{<:SpeedyWeather.RingGrids.AbstractGrid}\nas_matrix::Bool: [OPTION] sort grid points into a matrix (interpolation-free), for OctahedralClenshawGrid, OctaHEALPixGrid only\nquadrant_rotation::NTuple{4, Int64}\nmatrix_quadrant::NTuple{4, Tuple{Int64, Int64}}\noutput_Grid::Type{<:SpeedyWeather.RingGrids.AbstractFullGrid}: [OPTION] the grid used for output, full grids only\nnlat_half::Int64: [OPTION] the resolution of the output grid, default: same nlat_half as in the dynamical core\nnlon::Int64\nnlat::Int64\nnpoints::Int64\nnlev::Int64\ninterpolator::SpeedyWeather.RingGrids.AbstractInterpolator\nu::Matrix{NF} where NF<:Union{Float32, Float64}\nv::Matrix{NF} where NF<:Union{Float32, Float64}\nvor::Matrix{NF} where NF<:Union{Float32, Float64}\ndiv::Matrix{NF} where NF<:Union{Float32, Float64}\ntemp::Matrix{NF} where NF<:Union{Float32, Float64}\npres::Matrix{NF} where NF<:Union{Float32, Float64}\nhumid::Matrix{NF} where NF<:Union{Float32, Float64}\nprecip_cond::Matrix{NF} where NF<:Union{Float32, Float64}\nprecip_conv::Matrix{NF} where NF<:Union{Float32, Float64}\n\n\n\n\n\n","category":"type"},{"location":"functions/#Function-and-type-index","page":"Function and type index","title":"Function and type index","text":"","category":"section"},{"location":"functions/#Parameters-and-constants","page":"Function and type index","title":"Parameters and constants","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.Parameters\nSpeedyWeather.Constants","category":"page"},{"location":"functions/#Boundaries-and-boundary-conditions","page":"Function and type index","title":"Boundaries and boundary conditions","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.Boundaries","category":"page"},{"location":"functions/#Spherical-harmonic-transform","page":"Function and type index","title":"Spherical harmonic transform","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.GeoSpectral\nSpeedyWeather.SpectralTransform\nSpeedyWeather.spectral\nSpeedyWeather.spectral!\nSpeedyWeather.gridded\nSpeedyWeather.gridded!\nSpeedyWeather.triangular_truncation\nSpeedyWeather.roundup_fft\nSpeedyWeather.spectral_truncation\nSpeedyWeather.spectral_truncation!\nSpeedyWeather.spectral_interpolation!\nSpeedyWeather.get_legendre_polynomials!\nSpeedyWeather.∇²!\nSpeedyWeather.∇²\nSpeedyWeather.∇⁻²!\nSpeedyWeather.∇⁻²\nSpeedyWeather.gradient_latitude!\nSpeedyWeather.gradient_latitude\nSpeedyWeather.gradient_longitude!\nSpeedyWeather.gradient_longitude\nSpeedyWeather.divergence!\nSpeedyWeather.curl!\nSpeedyWeather._divergence!\nSpeedyWeather.curl_div!\nSpeedyWeather.UV_from_vordiv!\nSpeedyWeather.UV_from_vor!\nSpeedyWeather.ϵlm\nSpeedyWeather.get_recursion_factors","category":"page"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.SpectralTransform","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.SpectralTransform","text":"S = SpectralTransform{NF<:AbstractFloat}(...)\n\nSpectralTransform struct that contains all parameters and preallocated arrays for the spectral transform.\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.spectral","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.spectral","text":"alms = spectral(    map::AbstractMatrix;\n                    Grid::Type{<:AbstractGrid}=DEFAULT_GRID,\n                    kwargs...)\n\nConverts map to grid(map) to execute spectral(map::AbstractGrid;kwargs...).\n\n\n\n\n\nalms = spectral(    map::AbstractGrid;\n                    Grid::Type{<:AbstractGrid}=DEFAULT_GRID,\n                    kwargs...)\n\nConverts map to Grid(map) to execute spectral(map::AbstractGrid;kwargs...).\n\n\n\n\n\nalms = spectral(    map::AbstractMatrix;\n                    Grid::Type{<:AbstractGrid}=DEFAULT_GRID,\n                    kwargs...)\n\nSpectral transform (grid to spectral) map to grid(map) to execute spectral(map::AbstractGrid;kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.spectral!","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.spectral!","text":"spectral!(  alms::LowerTriangularMatrix,\n            map::AbstractGrid,\n            S::SpectralTransform)\n\nSpectral transform (grid to spectral space) from the gridded field map on a grid<:AbstractGrid to a LowerTriangularMatrix of spherical harmonic coefficients alms. Uses FFT in the zonal direction, and a Legendre Transform in the meridional direction exploiting symmetries. The spectral transform is number format-flexible as long as the parametric types of map, alms, S are identical. The spectral transform is grid-flexible as long as the typeof(map)<:AbstractGrid.  Uses the precalculated arrays, FFT plans and other constants in the SpectralTransform struct S.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.gridded","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.gridded","text":"map = gridded(  alms::AbstractMatrix;\n                recompute_legendre::Bool=true,\n                grid::Type{<:AbstractGrid}=DEFAULT_GRID)\n\nSpectral transform (spectral to grid space) from spherical coefficients alms to a newly allocated gridded field map. Based on the size of alms the grid type grid, the spatial resolution is retrieved based on the truncation defined for grid. SpectralTransform struct S is allocated to execute gridded(alms,S).\n\n\n\n\n\nmap = gridded(  alms::AbstractMatrix,\n                S::SpectralTransform)\n\nSpectral transform (spectral to grid space) from spherical coefficients alms to a newly allocated gridded field map with precalculated properties based on the SpectralTransform struct S. alms is converted to a LowerTriangularMatrix to execute the in-place gridded!.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.gridded!","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.gridded!","text":"gridded!(\n    diagn::DiagnosticVariables,\n    progn::PrognosticVariables,\n    lf::Int64,\n    model::SpeedyWeather.ModelSetup\n)\n\n\nPropagate the spectral state of progn to diagn using time step/leapfrog index lf. Function barrier that calls gridded! for the respective model.\n\n\n\n\n\ngridded!(\n    diagn::SpeedyWeather.DiagnosticVariablesLayer,\n    progn::SpeedyWeather.PrognosticLayerTimesteps,\n    lf::Int64,\n    model::Barotropic\n)\n\n\nPropagate the spectral state of the prognostic variables progn to the diagnostic variables in diagn for the barotropic vorticity model. Updates grid vorticity, spectral stream function and spectral and grid velocities u,v.\n\n\n\n\n\ngridded!(\n    diagn::SpeedyWeather.DiagnosticVariablesLayer,\n    progn::SpeedyWeather.PrognosticLayerTimesteps,\n    lf::Int64,\n    model::ShallowWater\n)\n\n\nPropagate the spectral state of the prognostic variables progn to the diagnostic variables in diagn for the shallow water model. Updates grid vorticity, grid divergence, grid interface displacement (pres_grid) and the velocities u,v.\n\n\n\n\n\ngridded!(\n    diagn::SpeedyWeather.DiagnosticVariablesLayer,\n    progn::SpeedyWeather.PrognosticLayerTimesteps,\n    lf::Int64,\n    model::PrimitiveEquation\n)\n\n\nPropagate the spectral state of the prognostic variables progn to the diagnostic variables in diagn for primitive equation models. Updates grid vorticity, grid divergence, grid temperature, pressure (pres_grid) and the velocities u,v.\n\n\n\n\n\ngridded!(   map::AbstractGrid,\n            alms::LowerTriangularMatrix,\n            S::SpectralTransform)\n\nSpectral transform (spectral to grid) of the spherical harmonic coefficients alms to a gridded field map. The spectral transform is number format-flexible as long as the parametric types of map, alms, S are identical. The spectral transform is grid-flexible as long as the typeof(map)<:AbstractGrid.  Uses the precalculated arrays, FFT plans and other constants in the SpectralTransform struct S.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.spectral_truncation","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.spectral_truncation","text":"alms_trunc = spectral_truncation(alms,trunc)\n\nReturns a spectral coefficient matrix alms_trunc that is truncated from alms to the size (trunc+1)². alms_trunc only contains those coefficient of alms for which m,l ≤ trunc, and l ≥ m are zero anyway. If trunc is larger than the implicit truncation in alms obtained from its size than spectral_interpolation is automatically called instead, returning alms_interp, a coefficient matrix that is larger than alms with padded zero coefficients.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.spectral_truncation!","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.spectral_truncation!","text":"spectral_truncation!(alms::AbstractMatrix,ltrunc::Integer,mtrunc::Integer)\n\nTruncate spectral coefficients alms in-place by setting (a) the upper right triangle to zero and (b) all coefficients for which the degree l is larger than the truncation ltrunc or order m larger than the truncaction mtrunc.\n\n\n\n\n\nspectral_truncation!(alms::LowerTriangularMatrix,ltrunc::Integer,mtrunc::Integer)\n\nTruncate spectral coefficients alms in-place by setting all coefficients for which the degree l is larger than the truncation ltrunc or order m larger than the truncaction mtrunc. Similar to spectral_truncation!(::AbstractMatrix, ...) but skips the upper triangle which is zero by design for LowerTriangularMatrix.\n\n\n\n\n\nspectral_truncation!(alms,trunc)\n\nTruncate spectral coefficients alms in-place by setting (a) the upper right triangle to zero and (b) all coefficients for which the degree l is larger than the truncation trunc.\n\n\n\n\n\nspectral_truncation!(alms)\n\nTruncate spectral coefficients alms in-place by setting the upper right triangle to zero. This is to enforce that all coefficients for which the degree l is larger than order m are zero.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.∇²!","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.∇²!","text":"∇²!(    ∇²alms::LowerTriangularMatrix,\n        alms::LowerTriangularMatrix,\n        S::SpectralTransform;\n        add::Bool=false,\n        flipsign::Bool=false,\n        inverse::Bool=false)\n\nLaplace operator ∇² applied to the spectral coefficients alms in spherical coordinates. The radius R is omitted in the eigenvalues which are precomputed in S. ∇²! is the in-place version which directly stores the output in the first argument ∇²alms.\n\nKeyword arguments\n\nadd=true adds the ∇²(alms) to the output\nflipsign=true computes -∇²(alms) instead\ninverse=true computes ∇⁻²(alms) instead\n\nDefault is add=false, flipsign=false, inverse=false. These options can be combined.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.∇⁻²!","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.∇⁻²!","text":"∇⁻²!(   ∇⁻²alms::LowerTriangularMatrix,\n        alms::LowerTriangularMatrix,\n        S::SpectralTransform;\n        add::Bool=false,\n        flipsign::Bool=false)\n\nCalls ∇²!(∇⁻²alms, alms, S; add, flipsign, inverse=true).\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.divergence!","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.divergence!","text":"divergence!(div::LowerTriangularMatrix,\n            u::LowerTriangularMatrix,\n            v::LowerTriangularMatrix,\n            S::SpectralTransform{NF};\n            flipsign::Bool=false,\n            add::Bool=false,\n            )\n\nDivergence of a vector u,v written into div, div = ∇⋅(u,v).  u,v are expected to have a 1/coslat-scaling included, then div is not scaled. flipsign option calculates -∇⋅(u,v) instead. add option calculates div += ∇⋅(u,v) instead. flipsign and add can be combined. This functions only creates the kernel and calls the generic divergence function _divergence! subsequently.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.curl!","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.curl!","text":"curl!(  curl::LowerTriangularMatrix,\n        u::LowerTriangularMatrix,\n        v::LowerTriangularMatrix,\n        S::SpectralTransform;\n        flipsign::Bool=false,\n        add::Bool=false,\n        )\n\nCurl of a vector u,v written into curl, curl = ∇×(u,v). u,v are expected to have a 1/coslat-scaling included, then curl is not scaled. flipsign option calculates -∇×(u,v) instead. add option calculates curl += ∇×(u,v) instead. flipsign and add can be combined. This functions only creates the kernel and calls the generic divergence function _divergence! subsequently with flipped u,v -> v,u for the curl.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.UV_from_vordiv!","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.UV_from_vordiv!","text":"UV_from_vordiv!(U::LowerTriangularMatrix,\n                V::LowerTriangularMatrix,\n                vor::LowerTriangularMatrix,\n                div::LowerTriangularMatrix,\n                S::SpectralTransform)\n\nGet U,V (=(u,v)*coslat) from vorticity ζ and divergence D in spectral space. Two operations are combined into a single linear operation. First, invert the spherical Laplace ∇² operator to get stream function from vorticity and velocity potential from divergence. Then compute zonal and meridional gradients to get U,V.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.SpeedyTransforms.UV_from_vor!","page":"Function and type index","title":"SpeedyWeather.SpeedyTransforms.UV_from_vor!","text":"UV_from_vor!(   U::LowerTriangularMatrix,\n                V::LowerTriangularMatrix,\n                vor::LowerTriangularMatrix,\n                S::SpectralTransform)\n\nGet U,V (=(u,v)*coslat) from vorticity ζ spectral space (divergence D=0) Two operations are combined into a single linear operation. First, invert the spherical Laplace ∇² operator to get stream function from vorticity. Then compute zonal and meridional gradients to get U,V.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Dynamics","page":"Function and type index","title":"Dynamics","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.bernoulli_potential!\nSpeedyWeather.volume_flux_divergence!\nSpeedyWeather.vorticity_fluxes!\nSpeedyWeather.vorticity_flux_curl!\nSpeedyWeather.vorticity_flux_divergence!","category":"page"},{"location":"functions/#SpeedyWeather.bernoulli_potential!","page":"Function and type index","title":"SpeedyWeather.bernoulli_potential!","text":"bernoulli_potential!(\n    diagn::SpeedyWeather.DiagnosticVariablesLayer{NF, Grid} where Grid<:SpeedyWeather.RingGrids.AbstractGrid{NF},\n    S::SpectralTransform\n) -> LowerTriangularMatrix{Complex{NF}} where NF<:AbstractFloat\n\n\nComputes the Laplace operator ∇² of the Bernoulli potential B in spectral space.\n\ncomputes the kinetic energy KE = ½(u²+v²) on the grid\ntransforms KE to spectral space\nadds geopotential for the Bernoulli potential in spectral space\ntakes the Laplace operator.\n\nThis version is used for both ShallowWater and PrimitiveEquation, only the geopotential calculation in geopotential! differs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.volume_flux_divergence!","page":"Function and type index","title":"SpeedyWeather.volume_flux_divergence!","text":"volume_flux_divergence!(\n    diagn::SpeedyWeather.DiagnosticVariablesLayer,\n    surface::SpeedyWeather.SurfaceVariables,\n    orog::SpeedyWeather.AbstractOrography,\n    constants::DynamicsConstants,\n    G::Geometry,\n    S::SpectralTransform\n)\n\n\nComputes the (negative) divergence of the volume fluxes uh,vh for the continuity equation, -∇⋅(uh,vh).\n\n\n\n\n\n","category":"function"},{"location":"functions/#Geometry","page":"Function and type index","title":"Geometry","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.Geometry\nSpeedyWeather.vertical_coordinates\nSpeedyWeather.GenLogisticCoefs\nSpeedyWeather.generalised_logistic","category":"page"},{"location":"functions/#SpeedyWeather.Geometry","page":"Function and type index","title":"SpeedyWeather.Geometry","text":"Construct Geometry struct containing parameters and arrays describing an iso-latitude grid <:AbstractGrid and the vertical levels. Pass on SpectralGrid to calculate the following fields\n\nspectral_grid::SpectralGrid: SpectralGrid that defines spectral and grid resolution\nGrid::Type{<:SpeedyWeather.RingGrids.AbstractGrid}: grid of the dynamical core\nnlat_half::Int64: resolution parameter nlat_half of Grid, # of latitudes on one hemisphere (incl Equator)\nnlon_max::Int64: maximum number of longitudes (at/around Equator)\nnlon::Int64: =nlon_max, same (used for compatibility), TODO: still needed?\nnlat::Int64: number of latitude rings\nnlev::Int64: number of vertical levels\nnpoints::Int64: total number of grid points\nradius::AbstractFloat: Planet's radius [m]\nlatd::Vector{Float64}: array of latitudes in degrees (90˚...-90˚)\nlond::Vector{Float64}: array of longitudes in degrees (0...360˚), empty for non-full grids\nlonds::Vector{NF} where NF<:AbstractFloat: longitude (-180˚...180˚) for each grid point in ring order\nlatds::Vector{NF} where NF<:AbstractFloat: latitude (-90˚...˚90) for each grid point in ring order\nsinlat::Vector{NF} where NF<:AbstractFloat: sin of latitudes\ncoslat::Vector{NF} where NF<:AbstractFloat: cos of latitudes\ncoslat⁻¹::Vector{NF} where NF<:AbstractFloat: = 1/cos(lat)\ncoslat²::Vector{NF} where NF<:AbstractFloat: = cos²(lat)\ncoslat⁻²::Vector{NF} where NF<:AbstractFloat: # = 1/cos²(lat)\nσ_levels_half::Vector{NF} where NF<:AbstractFloat: σ at half levels, σ_k+1/2\nσ_levels_full::Vector{NF} where NF<:AbstractFloat: σ at full levels, σₖ\nσ_levels_thick::Vector{NF} where NF<:AbstractFloat: σ level thicknesses, σₖ₊₁ - σₖ\nln_σ_levels_full::Vector{NF} where NF<:AbstractFloat: log of σ at full levels, include surface (σ=1) as last element\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpeedyWeather.GenLogisticCoefs","page":"Function and type index","title":"SpeedyWeather.GenLogisticCoefs","text":"Coefficients of the generalised logistic function to describe the vertical coordinate. Default coefficients A,K,C,Q,B,M,ν are fitted to the old L31 configuration at ECMWF.\n\nFollowing the notation of https://en.wikipedia.org/wiki/Generalisedlogisticfunction (Dec 15 2021).\n\nChange default parameters for more/fewer levels in the stratosphere vs troposphere vs boundary layer.\n\n\n\n\n\n","category":"type"},{"location":"functions/#SpeedyWeather.generalised_logistic","page":"Function and type index","title":"SpeedyWeather.generalised_logistic","text":"Generalised logistic function based on the coefficients in coefs.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Time-stepping","page":"Function and type index","title":"Time stepping","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.time_stepping!\nSpeedyWeather.timestep!\nSpeedyWeather.first_timesteps!\nSpeedyWeather.leapfrog!","category":"page"},{"location":"functions/#SpeedyWeather.time_stepping!","page":"Function and type index","title":"SpeedyWeather.time_stepping!","text":"time_stepping!(\n    progn::PrognosticVariables,\n    diagn::DiagnosticVariables,\n    model::SpeedyWeather.ModelSetup\n) -> PrognosticVariables\n\n\nMain time loop that that initializes output and feedback, loops over all time steps and calls the output and feedback functions.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.timestep!","page":"Function and type index","title":"SpeedyWeather.timestep!","text":"timestep!(\n    progn::PrognosticVariables,\n    diagn::DiagnosticVariables,\n    dt::Real,\n    i::Integer,\n    model::Barotropic\n)\ntimestep!(\n    progn::PrognosticVariables,\n    diagn::DiagnosticVariables,\n    dt::Real,\n    i::Integer,\n    model::Barotropic,\n    lf1::Int64\n)\ntimestep!(\n    progn::PrognosticVariables,\n    diagn::DiagnosticVariables,\n    dt::Real,\n    i::Integer,\n    model::Barotropic,\n    lf1::Int64,\n    lf2::Int64\n)\n\n\nCalculate a single time step for the model <: Barotropic.\n\n\n\n\n\ntimestep!(\n    progn::PrognosticVariables{NF<:AbstractFloat},\n    diagn::DiagnosticVariables{NF<:AbstractFloat, Grid} where Grid<:SpeedyWeather.RingGrids.AbstractGrid{NF<:AbstractFloat},\n    dt::Real,\n    i::Integer,\n    model::ShallowWater\n) -> Union{Nothing, SpeedyWeather.RingGrids.AbstractGrid{NF} where NF<:AbstractFloat}\ntimestep!(\n    progn::PrognosticVariables{NF<:AbstractFloat},\n    diagn::DiagnosticVariables{NF<:AbstractFloat, Grid} where Grid<:SpeedyWeather.RingGrids.AbstractGrid{NF<:AbstractFloat},\n    dt::Real,\n    i::Integer,\n    model::ShallowWater,\n    lf1::Int64\n) -> Union{Nothing, SpeedyWeather.RingGrids.AbstractGrid{NF} where NF<:AbstractFloat}\ntimestep!(\n    progn::PrognosticVariables{NF<:AbstractFloat},\n    diagn::DiagnosticVariables{NF<:AbstractFloat, Grid} where Grid<:SpeedyWeather.RingGrids.AbstractGrid{NF<:AbstractFloat},\n    dt::Real,\n    i::Integer,\n    model::ShallowWater,\n    lf1::Int64,\n    lf2::Int64\n) -> Union{Nothing, SpeedyWeather.RingGrids.AbstractGrid{NF} where NF<:AbstractFloat}\n\n\nCalculate a single time step for the model <: ShallowWater.\n\n\n\n\n\ntimestep!(\n    progn::PrognosticVariables{NF<:AbstractFloat},\n    diagn::DiagnosticVariables{NF<:AbstractFloat, Grid} where Grid<:SpeedyWeather.RingGrids.AbstractGrid{NF<:AbstractFloat},\n    dt::Real,\n    i::Integer,\n    model::PrimitiveEquation\n) -> Any\ntimestep!(\n    progn::PrognosticVariables{NF<:AbstractFloat},\n    diagn::DiagnosticVariables{NF<:AbstractFloat, Grid} where Grid<:SpeedyWeather.RingGrids.AbstractGrid{NF<:AbstractFloat},\n    dt::Real,\n    i::Integer,\n    model::PrimitiveEquation,\n    lf1::Int64\n) -> Any\ntimestep!(\n    progn::PrognosticVariables{NF<:AbstractFloat},\n    diagn::DiagnosticVariables{NF<:AbstractFloat, Grid} where Grid<:SpeedyWeather.RingGrids.AbstractGrid{NF<:AbstractFloat},\n    dt::Real,\n    i::Integer,\n    model::PrimitiveEquation,\n    lf1::Int64,\n    lf2::Int64\n) -> Any\n\n\nCalculate a single time step for the model<:PrimitiveEquation\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.first_timesteps!","page":"Function and type index","title":"SpeedyWeather.first_timesteps!","text":"first_timesteps!(\n    progn::PrognosticVariables,\n    diagn::DiagnosticVariables,\n    model::SpeedyWeather.ModelSetup,\n    output::SpeedyWeather.AbstractOutputWriter\n) -> typeof(time)\n\n\nPerforms the first two initial time steps (Euler forward, unfiltered leapfrog) to populate the prognostic variables with two time steps (t=0,Δt) that can then be used in the normal leap frogging.\n\n\n\n\n\n","category":"function"},{"location":"functions/#SpeedyWeather.leapfrog!","page":"Function and type index","title":"SpeedyWeather.leapfrog!","text":"leapfrog!(\n    A_old::LowerTriangularMatrix{Complex{NF<:AbstractFloat}},\n    A_new::LowerTriangularMatrix{Complex{NF<:AbstractFloat}},\n    tendency::LowerTriangularMatrix{Complex{NF<:AbstractFloat}},\n    dt::Real,\n    lf::Int64,\n    L::Leapfrog{NF<:AbstractFloat}\n)\n\n\nPerforms one leapfrog time step with (lf=2) or without (lf=1) Robert+William's filter (see William (2009), Montly Weather Review, Eq. 7-9).\n\n\n\n\n\n","category":"function"},{"location":"functions/#Longwave-radiation","page":"Function and type index","title":"Longwave radiation","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.radset!\nSpeedyWeather.radlw_down!\nSpeedyWeather.compute_bbe!\nSpeedyWeather.radlw_up!","category":"page"},{"location":"functions/#Shortwave-radiation","page":"Function and type index","title":"Shortwave radiation","text":"","category":"section"},{"location":"functions/","page":"Function and type index","title":"Function and type index","text":"SpeedyWeather.shortwave_radiation!\nSpeedyWeather.solar!\nSpeedyWeather.sol_oz!\nSpeedyWeather.cloud!\nSpeedyWeather.radsw!","category":"page"},{"location":"parametrizations/#Parameterizations","page":"Parameterizations","title":"Parameterizations","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"This page describes the mathematical formulation of the parameterizations used in SpeedyWeather.jl to represent physical processes in the atmosphere. Every section is followed by a brief description of implementation details.","category":"page"},{"location":"parametrizations/#Convection","page":"Parameterizations","title":"Convection","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Large-scale-condensation","page":"Parameterizations","title":"Large-scale condensation","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Clouds","page":"Parameterizations","title":"Clouds","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Short-wave-radiation","page":"Parameterizations","title":"Short-wave radiation","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Long-wave-radiation","page":"Parameterizations","title":"Long-wave radiation","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Surface-fluxes-of-momentum-and-energy","page":"Parameterizations","title":"Surface fluxes of momentum and energy","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"parametrizations/#Vertical-diffusion","page":"Parameterizations","title":"Vertical diffusion","text":"","category":"section"},{"location":"parametrizations/","page":"Parameterizations","title":"Parameterizations","text":"more to come ...","category":"page"},{"location":"how_to_run_speedy/#How-to-run-SpeedyWeather.jl","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"Creating a SpeedyWeather.jl simulation and running it consists conceptually of 4 steps","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"Create a SpectralGrid which defines the grid and spectral resolution\nCreate a model\nInitialize a model to obtain a Simulation.\nRun the simulation.","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"In the following we will describe these steps in more detail, but let's start with some examples first.","category":"page"},{"location":"how_to_run_speedy/#Example-1:-2D-turbulence-on-a-non-rotating-sphere","page":"How to run SpeedyWeather.jl","title":"Example 1: 2D turbulence on a non-rotating sphere","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"We want to use the barotropic model to simulate some free-decaying 2D turbulence on the sphere without rotation. We start by defining the SpectralGrid object. To have a resolution of about 100km, we choose a spectral resolution of T127 (see Available resolutions) and nlev=1 vertical levels. The SpectralGrid object will provide us with some more information","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> spectral_grid = SpectralGrid(trunc=127,nlev=1)\nSpectralGrid:\n Spectral:   T127 LowerTriangularMatrix{Complex{Float32}}, radius = 6.371e6 m\n Grid:       40320-element, 192-ring OctahedralGaussianGrid{Float32} (quadratic)\n Resolution: 112km (average)\n Vertical:   1-level SigmaCoordinates","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"We could have specified further options, but let's ignore that for now. Next step we create a planet that's like Earth but not rotating","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> still_earth = Earth(rotation=0)\nMain.SpeedyWeather.Earth\n  rotation: Float64 0.0\n  gravity: Float64 9.81\n  daily_cycle: Bool true\n  length_of_day: Float64 24.0\n  seasonal_cycle: Bool true\n  length_of_year: Float64 365.25\n  equinox: Dates.DateTime\n  axial_tilt: Float64 23.4","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"There are other options to create a planet but they are irrelevant for the barotropic vorticity equations. We also want to specify the initial conditions, randomly distributed vorticity is already defined","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> initial_conditions = StartWithRandomVorticity()\nStartWithRandomVorticity\n  power_law: Float64 -3.0\n  amplitude: Float64 1.0e-5","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"By default, the power of vorticity is spectrally distributed with k^-3, k being the horizontal wavenumber, and the amplitude is 10^-5text s^-1.","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"Now we want to construct a BarotropicModel with these","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> model = BarotropicModel(;spectral_grid, initial_conditions, planet=still_earth);","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"The model contains all the parameters, but isn't initialized yet, which we can do with and then run it.","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> simulation = initialize!(model);\njulia> run!(simulation,n_days=30)","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"The run! command will always return the prognostic variables, which, by default, are  plotted for surface relative vorticity with a unicode plot. The resolution of the plot is not necessarily representative but it lets us have a quick look at the result","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"(Image: Barotropic vorticity unicode plot)","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"Woohoo! I can see turbulence! You could pick up where this simulation stopped by simply doing run!(simulation,n_days=50) again. We didn't store any output, which you can do by run!(simulation,output=true), which will switch on NetCDF output with default settings. More options on output in NetCDF output.","category":"page"},{"location":"how_to_run_speedy/#Example-2:-Shallow-water-with-mountains","page":"How to run SpeedyWeather.jl","title":"Example 2: Shallow water with mountains","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"As a second example, let's investigate the Galewsky et al.[1] test case for the shallow water equations with and without mountains. As the shallow water system has also only one level, we can reuse the SpectralGrid from Example 1.","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> spectral_grid = SpectralGrid(trunc=127,nlev=1)","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"Now as a first simulation, we want to disable any orography, so we create a NoOrography","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> orography = NoOrography(spectral_grid)\nNoOrography{Float32, OctahedralGaussianGrid{Float32}}","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"Although the orography is zero, you have to pass on spectral_grid so that it can still initialize zero-arrays of the right size and element type. Awesome. This time the initial conditions should be set the the Galewsky et al.[1] zonal jet, which is already defined as","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> initial_conditions = ZonalJet()\nZonalJet\n  latitude: Float64 45.0\n  width: Float64 19.28571428571429\n  umax: Float64 80.0\n  perturb_lat: Float64 45.0\n  perturb_lon: Float64 270.0\n  perturb_xwidth: Float64 19.098593171027442\n  perturb_ywidth: Float64 3.819718634205488\n  perturb_height: Float64 120.0","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"The jet sits at 45˚N with a maximum velocity of 80m/s and a perturbation as described in their paper. Now we construct a model, but this time a ShallowWaterModel","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> model = ShallowWaterModel(;spectral_grid, orography, initial_conditions);\njulia> simulation = initialize!(model);","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"(Image: Galewsky jet unicode plot)","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"Oh yeah. That looks like the wobbly jet in their paper. Let's run it again for another 6 days but this time also store NetCDF output.","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> run!(simulation,n_days=6,output=true)\nWeather is speedy: run 0002 100%|███████████████████████| Time: 0:00:12 (115.37 years/day)","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"The progress bar tells us that the simulation run got the identification \"0002\", meaning that data is stored in the folder /run_0002, so let's plot that data properly (and not just using UnicodePlots).","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> using PyPlot, NCDatasets\njulia> ds = NCDataset(\"run_0002/output.nc\");\njulia> ds[\"vor\"]\nvor (384 × 192 × 1 × 25)\n  Datatype:    Float32\n  Dimensions:  lon × lat × lev × time\n  Attributes:\n   units                = 1/s\n   missing_value        = NaN\n   long_name            = relative vorticity\n   _FillValue           = NaN","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"Vorticity vor is stored as a 384x192x1x25 array, we may want to look at the first time step, which is the end of the previous simulation (time=6days) which we didn't store output for.","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> vor = ds[\"vor\"][:,:,1,1];\njulia> lat = ds[\"lat\"][:];\njulia> lon = ds[\"lon\"][:];\njulia> pcolormesh(lon,lat,vor')","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"Which looks like","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"(Image: Galewsky jet pyplot)","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"You see that the unicode plot heavily coarse-grains the simulation, well it's unicode after all! And now the last time step, that means time=12days is","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> vor = ds[\"vor\"][:,:,1,25];\njulia> pcolormesh(lon,lat,vor')","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"(Image: Galewsky jet pyplot)","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"The jet broke up into many small eddies, but the turbulence is still confined to the northern hemisphere, cool! How this may change when we add mountains (we had NoOrography above!), say Earth's orography, you may ask? Let's try it out! We create an EarthOrography struct like so","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> orography = EarthOrography(spectral_grid)\nEarthOrography{Float32, OctahedralGaussianGrid{Float32}}:\n path::String = SpeedyWeather.jl/input_data\n file::String = orography_F512.nc\n scale::Float64 = 1.0\n smoothing::Bool = true\n smoothing_power::Float64 = 1.0\n smoothing_strength::Float64 = 0.1\n smoothing_truncation::Int64 = 85","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"It will read the orography from file as shown, and there are some smoothing options too, but let's not change them. Same as before, create a model, initialize into a simulation, run. This time directly for 12 days so that we can compare with the last plot","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"julia> model = ShallowWaterModel(;spectral_grid, orography, initial_conditions);\njulia> simulation = initialize!(model);\njulia> run!(simulation,n_days=12,output=true)\nWeather is speedy: run 0003 100%|███████████████████████| Time: 0:00:35 (79.16 years/day)","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"This time the run got the id \"0003\", but otherwise we do as before.","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"(Image: Galewsky jet pyplot)","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"Interesting! The initial conditions have zero velocity in the southern hemisphere, but still, one can see some imprint of the orography on vorticity. You can spot the coastline of Antarctica; the Andes and Greenland are somewhat visible too. Mountains also completely changed the flow after 12 days, probably not surprising!","category":"page"},{"location":"how_to_run_speedy/#SpectralGrid","page":"How to run SpeedyWeather.jl","title":"SpectralGrid","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"The life of every SpeedyWeather.jl simulation starts with a SpectralGrid object. We have seen some examples above, now let's look into the details","category":"page"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"SpectralGrid","category":"page"},{"location":"how_to_run_speedy/#SpeedyWeather.SpectralGrid","page":"How to run SpeedyWeather.jl","title":"SpeedyWeather.SpectralGrid","text":"Defines the horizontal spectral resolution and corresponding grid and the vertical coordinate for SpeedyWeather.jl. Options are\n\nNF::Type{<:AbstractFloat}: number format used throughout the model\ntrunc::Int64: horizontal resolution as the maximum degree of spherical harmonics\nGrid::Type{<:SpeedyWeather.RingGrids.AbstractGrid}: horizontal grid used for calculations in grid-point space\ndealiasing::Float64: how to match spectral with grid resolution: dealiasing factor, 1=linear, 2=quadratic, 3=cubic grid\nradius::Float64: radius of the sphere [m]\nnlat_half::Int64: number of latitude rings on one hemisphere (Equator incl)\nnpoints::Int64: total number of grid points in the horizontal\nnlev::Int64: number of vertical levels\nvertical_coordinates::SpeedyWeather.VerticalCoordinates: coordinates used to discretize the vertical\n\nnlat_half and npoints should not be chosen but are derived from trunc, Grid and dealiasing.\n\n\n\n\n\n","category":"type"},{"location":"how_to_run_speedy/#References","page":"How to run SpeedyWeather.jl","title":"References","text":"","category":"section"},{"location":"how_to_run_speedy/","page":"How to run SpeedyWeather.jl","title":"How to run SpeedyWeather.jl","text":"[1] Galewsky, Scott, Polvani, 2004. An initial-value problem for testing numerical models of the global shallow-water equations, Tellus A. DOI: 10.3402/tellusa.v56i5.14436","category":"page"},{"location":"speedytransforms/#SpeedyTransforms","page":"Submodule: SpeedyTransforms","title":"SpeedyTransforms","text":"","category":"section"},{"location":"speedytransforms/","page":"Submodule: SpeedyTransforms","title":"Submodule: SpeedyTransforms","text":"SpeedyTransforms is a submodule that has been developed for SpeedyWeather.jl which is technically independent (SpeedyWeather.jl however imports it) and can also be used without running simulations. It is just not put into its own respective repository.","category":"page"},{"location":"speedytransforms/#Functions","page":"Submodule: SpeedyTransforms","title":"Functions","text":"","category":"section"},{"location":"grids/#Grids","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"The spectral transform (the Spherical Harmonic Transform) in SpeedyWeather.jl supports any ring-based equi-longitude grid. Several grids are already implemented but other can be added. The following pages will describe an overview of these grids and but let's start but how they can be used","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"julia> spectral_grid = SpectralGrid(Grid = FullGaussianGrid)\nSpectralGrid:\n Spectral:   T31 LowerTriangularMatrix{Complex{Float32}}, radius = 6.371e6 m\n Grid:       4608-element, 48-ring FullGaussianGrid{Float32} (quadratic)\n Resolution: 333km (average)\n Vertical:   8-level SigmaCoordinates","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The life of every SpeedyWeather.jl simulation starts with a SpectralGrid object which defines the resolution in spectral and in grid-point space. The generator SpectralGrid() can take as a keyword argument Grid which can be any of the grids described below. The resolution of the grid, however, is not directly chosen, but determined from the spectral resolution trunc and the dealiasing factor. More in Matching spectral and grid resolution.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"info: RingGrids is a module too!\nWhile RingGrids is the underlying module that SpeedyWeather.jl uses for data structs on the sphere, the module can also be used independently of SpeedyWeather, for example to interpolate between data on different grids. See RingGrids","category":"page"},{"location":"grids/#Ring-based-equi-longitude-grids","page":"Grids","title":"Ring-based equi-longitude grids","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"SpeedyWeather.jl's spectral transform supports all ring-based equi-longitude grids. These grids have their grid points located on rings with constant latitude and on these rings the points are equi-spaced in longitude. There is technically no constrain on the spacing of the latitude rings, but the Legendre transform requires a quadrature to map those to spectral space and back. Common choices for latitudes are the Gaussian latitudes which use the Gaussian quadrature, or equi-angle latitudes (i.e. just regular latitudes but excluding the poles) that use the Clenshaw-Curtis quadrature. The longitudes have to be equi-spaced on every ring, which is necessary for the fast Fourier transform, as one would otherwise need to use a non-uniform Fourier transform. In SpeedyWeather.jl the first grid point on any ring can have a longitudinal offset though, for example by spacing 4 points around the globe at 45˚E, 135˚E, 225˚E, and 315˚E. In this case the offset is 45˚E as the first point is not at 0˚E.","category":"page"},{"location":"grids/#Implemented-grids","page":"Grids","title":"Implemented grids","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"All grids in SpeedyWeather.jl are a subtype of AbstractGrid, i.e. <: AbstractGrid. We further distinguish between full, and reduced grids. Full grids have the same number of longitude points on every latitude ring (i.e. points converge towards the poles) and reduced grids reduce the number of points towards the poles to have them more evenly spread out across the globe. More evenly does not necessarily mean that a grid is equal-area, meaning that every grid cell covers exactly the same area (although the shape changes).","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Currently the following full grids <: AbstractFullGrid are implemented","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"FullGaussianGrid, a full grid with Gaussian latitudes\nFullClenshawGrid, a full grid with equi-angle latitudes","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"and additionally we have FullHEALPixGrid and FullOctaHEALPixGrid which are the full grid equivalents to the HEALPix grid and the OctaHEALPix grid discussed below. Full grid equivalent means that they have the same latitude rings, but no reduction in the number of points per ring towards the poles and no longitude offset. Other implemented reduced grids are","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"OctahedralGaussianGrid, a reduced grid with Gaussian latitudes based on an octahedron\nOctahedralClenshawGrid, similar but based on equi-angle latitudes\nHEALPixGrid, an equal-area grid based on a dodecahedron with 12 faces\nOctaHEALPixGrid, an equal-area grid from the class of HEALPix grids but based on an octahedron.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"An overview of these grids is visualised here","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"(Image: Overview of implemented grids in SpeedyWeather.jl)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Visualised are each grid's grid points (white dots) and grid faces (white lines). All grids shown have 16 latitude rings on one hemisphere, Equator included. The total number of grid points is denoted in the top left of every subplot. The sphere is shaded with grey, orange and turquoise regions to denote the hemispheres in a and b, the 8 octahedral faces c, d,f and the 12 dodecahedral faces (or base pixels) in e. Coastlines are added for orientation.","category":"page"},{"location":"grids/#Grid-resolution","page":"Grids","title":"Grid resolution","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"All grids use the same resolution parameter nlat_half, i.e. the number of rings on one hemisphere, Equator included. The Gaussian grids (full and reduced) do not have a ring on the equator, so their total number of rings nlat is always even and twice nlat_half. Clenshaw-Curtis grids and the HEALPix grids have a ring on the equator such their total number of rings is always odd and one less than the Gaussian grids at the same nlat_half. ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"info: HEALPix grids do not use Nside as resolution parameter\nThe original formulation for HEALPix grids use N_side, the number of grid points along the edges of each basepixel (8 in the figure above), SpeedyWeather.jl uses nlat_half, the number of rings on one hemisphere, Equator included, for all grids. This is done for consistency across grids. We may use N_side for the documentation or within functions though.","category":"page"},{"location":"grids/#Matching-spectral-and-grid-resolution","page":"Grids","title":"Matching spectral and grid resolution","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"A given spectral resolution can be matched to a variety of grid resolutions. A cubic grid, for example, combines a spectral truncation T with a grid resolution N (=nlat_half) such that T + 1 = N. Using T31 and an O32 is therefore often abbreviated as Tco31 meaning that the spherical harmonics are truncated at l_max=31 in combination with N=32, i.e. 64 latitude rings in total on an octahedral Gaussian grid.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Let J be the total number of rings. Then we have","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"T approx J for linear truncation\nfrac32T approx J for quadratic truncation\n2T approx J for cubic truncation","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"and in general fracm+12T approx J for m-th order truncation. So the higher the truncaction order the more grid points are used in combination with the same spectral resolution. A higher truncation order therefore makes all grid-point calculations more expensive, but can represent products of terms on the grid (which will have higher wavenumber components) to a higher accuracy as more grid points are available within a given wavelength. Using a sufficiently high truncation is therefore one way to avoid aliasing. In SpeedyWeather.jl the parameter dealiasing controls this option, = 1 would be linear, = 2 quadratic, = 3 cubic etc.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"For now just a quick overview of how the grid resolution changes when dealiasing is passed onto SpectralGrid on the FullGaussianGrid","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"trunc dealiasing FullGaussianGrid size\n31 1 64x32\n31 2 96x48\n31 3 128x64\n42 1 96x48\n42 2 128x64\n42 3 192x96\n... ... ...","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"You will obtain this information every time you create a SpectralGrid(;Grid,trunc,dealiasing).","category":"page"},{"location":"grids/#Full-Gaussian-grid","page":"Grids","title":"Full Gaussian grid","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"...","category":"page"},{"location":"grids/#Full-Clenshaw-Curtis-grid","page":"Grids","title":"Full Clenshaw-Curtis grid","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"...","category":"page"},{"location":"grids/#Octahedral-Gaussian-grid","page":"Grids","title":"Octahedral Gaussian grid","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"...","category":"page"},{"location":"grids/#The-HEALPix-grid","page":"Grids","title":"The HEALPix grid","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"Technically, HEALPix grids are a class of grids that tessalate the sphere into faces that are often called basepixels. For each member of this class there are N_varphi basepixels in zonal direction and N_theta basepixels in meridional direction. For N_varphi = 4 and N_theta = 3 we obtain the classical HEALPix grid with N_varphi N_theta = 12 basepixels shown above in Implemented Grids. Each basepixel has a quadratic number of grid points in them. There's an equatorial zone where the number of zonal grid points is constant (always 2N, so 32 at N=16) and there are polar caps above and below the equatorial zone with the border at  cos(theta) = 23 (theta in colatitudes).","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"Following Górski, 2004[1], the z=cos(theta) colatitude of the j-th ring in the north polar cap, j=1N_side with 2N_side = N is ","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"z = 1 - fracj^23N_side^2","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"and on that ring, the longitude phi of the i-th point (i is the in-ring-index) is at","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"phi = fracpi2j(i-tfrac12)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The in-ring index i goes from i=14 for the first (i.e. northern-most) ring, i=18 for the second ring and i = 14j for the j-th ring in the northern polar cap.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"In the north equatorial belt j=N_side2N_side this changes to","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"z = frac43 - frac2j3N_side","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"and the longitudes change to (i is always i = 14N_side in the equatorial belt meaning the number of longitude points is constant here)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"phi = fracpi2N_side(i - fracs2) quad s = (j - N_side + 1) mod 2","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The modulo function comes in as there is an alternating longitudinal offset from the prime meridian (see Implemented grids). For the southern hemisphere the grid point locations can be obtained by mirror symmetry.","category":"page"},{"location":"grids/#Grid-cell-boundaries","page":"Grids","title":"Grid cell boundaries","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"The cell boundaries are obtained by setting i = k + 12 or i = k + 12 + j (half indices) into the equations above, such that z(phik), a function for the cosine of colatitude z of index k and the longitude phi is obtained. These are then (northern polar cap)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"z = 1 - frack^23N_side^2left(fracpi2phi_tright)^2 quad z = 1 - frack^23N_side^2left(fracpi2phi_t - piright)^2","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"with phi_t = phi mod tfracpi2 and in the equatorial belt","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"z = frac23-frac4k3N_side pm frac8phi3pi","category":"page"},{"location":"grids/#OctaHEALPix-grid","page":"Grids","title":"OctaHEALPix grid","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"While the classic HEALPix grid is based on a dodecahedron, other choices for N_varphi and N_theta in the class of HEALPix grids will change the number of faces there are in zonal/meridional direction. With N_varphi = 4 and N_theta = 1 we obtain a HEALPix grid that is based on an octahedron, which has the convenient property that there are twice as many longitude points around the equator than there are latitude rings between the poles. This is a desirable for truncation as this matches the distances too, 2pi around the Equator versus pi between the poles. N_varphi = 6 N_theta = 2 or N_varphi = 8 N_theta = 3 are other possible choices for this, but also more complicated. See  Górski, 2004[1] for further examples and visualisations of these grids.","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"We call the N_varphi = 4 N_theta = 1 HEALPix grid the OctaHEALPix grid, which combines the equal-area property of the HEALPix grids with the octahedron that's also used in the OctahedralGaussianGrid or the OctahedralClenshawGrid. As N_theta = 1 there is no equatorial belt which simplifies the grid. The latitude of the j-th isolatitude ring on the OctaHEALPixGrid is defined by","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"z = 1 - fracj^2N^2","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"with j=1N, and similarly for the southern hemisphere by symmetry. On this grid N_side = N where N= nlat_half, the number of latitude rings on one hemisphere, Equator included, because each of the 4 basepixels spans from pole to pole and covers a quarter of the sphere. The longitudes with in-ring- index i = 14j are","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"phi = fracpi2j(i - tfrac12)","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"and again, the southern hemisphere grid points are obtained by symmetry.","category":"page"},{"location":"grids/#Grid-cell-boundaries-2","page":"Grids","title":"Grid cell boundaries","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"Similar to the grid cell boundaries for the HEALPix grid, the OctaHEALPix grid's boundaries are","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"z = 1 - frack^2N^2left(fracpi2phi_tright)^2 quad z = 1 - frack^2N^2left(fracpi2phi_t - piright)^2","category":"page"},{"location":"grids/","page":"Grids","title":"Grids","text":"The 3N_side^2 in the denominator of the HEALPix grid came simply N^2 for the OctaHEALPix grid and there's no separate equation for the equatorial belt (which doesn't exist in the OctaHEALPix grid).","category":"page"},{"location":"grids/#References","page":"Grids","title":"References","text":"","category":"section"},{"location":"grids/","page":"Grids","title":"Grids","text":"[1] Górski, Hivon, Banday, Wandelt, Hansen, Reinecke, Bartelmann, 2004. HEALPix: A FRAMEWORK FOR HIGH-RESOLUTION DISCRETIZATION AND FAST ANALYSIS OF DATA DISTRIBUTED ON THE SPHERE, The Astrophysical Journal. doi:10.1086/427976","category":"page"},{"location":"boundary_conditions/#Boundary-conditions","page":"Boundary conditions","title":"Boundary conditions","text":"","category":"section"},{"location":"boundary_conditions/","page":"Boundary conditions","title":"Boundary conditions","text":"This page describes the formulation of boundary conditions and their implementation.","category":"page"},{"location":"lowertriangularmatrices/#LowerTriangularMatrices","page":"Submodule: LowerTriangularMatrices","title":"LowerTriangularMatrices","text":"","category":"section"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"LowerTriangularMatrices is a submodule that has been developed for SpeedyWeather.jl which is technically independent (SpeedyWeather.jl however imports it and so does SpeedyTransforms) and can also be used without running simulations. It is just not put into its own respective repository.","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"This module defines LowerTriangularMatrix, a lower triangular matrix, which in contrast to LinearAlgebra.LowerTriangular does not store the entries above the diagonal. SpeedyWeather.jl uses LowerTriangularMatrix which is defined as a subtype of AbstractMatrix to store the spherical harmonic coefficients (see Spectral packing). ","category":"page"},{"location":"lowertriangularmatrices/#Creation-of-LowerTriangularMatrix","page":"Submodule: LowerTriangularMatrices","title":"Creation of LowerTriangularMatrix","text":"","category":"section"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"A LowerTriangularMatrix can be created using zeros,ones,rand, or randn","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"julia> using SpeedyWeather.LowerTriangularMatrices\n\njulia> L = rand(LowerTriangularMatrix{Float32},5,5)\n5×5 LowerTriangularMatrix{Float32}:\n 0.912744   0.0        0.0       0.0       0.0\n 0.0737592  0.230592   0.0       0.0       0.0\n 0.799679   0.0765255  0.888098  0.0       0.0\n 0.670835   0.997938   0.505276  0.492966  0.0\n 0.949321   0.193692   0.793623  0.152817  0.357968","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"or the undef initializor LowerTriangularMatrix{Float32}(undef,3,3). The element type is arbitrary though, you can use any type T too.","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"Alternatively, it can be created through conversion from Matrix, which drops the upper triangle entries and sets them to zero","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"julia> M = rand(Float16,3,3)\n3×3 Matrix{Float16}:\n 0.2222  0.694    0.3452\n 0.2158  0.04443  0.274\n 0.9746  0.793    0.6294\n\njulia> LowerTriangularMatrix(M)\n3×3 LowerTriangularMatrix{Float16}:\n 0.2222  0.0      0.0\n 0.2158  0.04443  0.0\n 0.9746  0.793    0.6294","category":"page"},{"location":"lowertriangularmatrices/#Indexing-LowerTriangularMatrix","page":"Submodule: LowerTriangularMatrices","title":"Indexing LowerTriangularMatrix","text":"","category":"section"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"LowerTriangularMatrix supports two types of indexing: 1) by denoting two indices, column and row [l,m] or 2) by denoting a single index [lm]. The double index works as expected","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"julia> L\n3×3 LowerTriangularMatrix{Float16}:\n 0.1499  0.0    0.0\n 0.1177  0.478  0.0\n 0.1709  0.756  0.3223\n\njulia> L[2,2]\nFloat16(0.478)","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"But the single index skips the zero entries in the upper triangle, i.e.","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"julia> L[4]\nFloat16(0.478)","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"which, important, is different from single indices of an AbstractMatrix","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"julia> Matrix(L)[4]\nFloat16(0.0)","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"In performance-critical code a single index should be used, as this directly maps to the index of the underlying data vector. The double index is somewhat slower as it first has to be converted to the corresponding single index.","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"Consequently, many loops in SpeedyWeather.jl are build with the following structure","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"n,m = size(L)\nij = 0\nfor j in 1:m\n    for i in j:n\n        ij += 1\n        L[ij] = i+j\n    end\nend","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"which loops over all lower triangle entries of L::LowerTriangularMatrix and the single index ij is simply counted up. However, one could also use [i,j] as indices in the loop body or to perform any calculation (i+j here). An iterator over all entries in the lower triangle can be created by","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"for ij in eachindex(L)\n    # do something\nend","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"The setindex! functionality of matrixes will throw a BoundsError when trying to write into the upper triangle of a LowerTriangularMatrix, for example","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"julia> L[2,1] = 0    # valid index\n0\n\njulia> L[1,2] = 0    # invalid index in the upper triangle\nERROR: BoundsError: attempt to access 3×3 LowerTriangularMatrix{Float32} at index [1, 2]","category":"page"},{"location":"lowertriangularmatrices/#Linear-algebra-with-LowerTriangularMatrix","page":"Submodule: LowerTriangularMatrices","title":"Linear algebra with LowerTriangularMatrix","text":"","category":"section"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"The LowerTriangularMatrices module's main purpose is not linear algebra, and it's implementation may not be efficient, however, many operations work as expected","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"julia> L = rand(LowerTriangularMatrix{Float32},3,3)\n3×3 LowerTriangularMatrix{Float32}:\n 0.57649   0.0       0.0\n 0.348685  0.875371  0.0\n 0.881923  0.850552  0.998306\n\njulia> L + L\n3×3 LowerTriangularMatrix{Float32}:\n 1.15298   0.0      0.0\n 0.697371  1.75074  0.0\n 1.76385   1.7011   1.99661\n\njulia> L * L\n3×3 Matrix{Float32}:\n 0.332341  0.0       0.0\n 0.506243  0.766275  0.0\n 1.68542   1.59366   0.996616","category":"page"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"Note, however, that the latter includes a conversion to Matrix, which is true for many operations, including inv or \\. Hence when trying to do more sophisticated linear algebra with LowerTriangularMatrix we quickly leave lower triangular-land and go back to normal matrix-land.","category":"page"},{"location":"lowertriangularmatrices/#Function-index","page":"Submodule: LowerTriangularMatrices","title":"Function index","text":"","category":"section"},{"location":"lowertriangularmatrices/","page":"Submodule: LowerTriangularMatrices","title":"Submodule: LowerTriangularMatrices","text":"LowerTriangularMatrix\nLowerTriangularMatrices.ij2k\nBase.fill!(L::LowerTriangularMatrix{T}, x) where T\nLowerTriangularMatrices.eachharmonic","category":"page"},{"location":"lowertriangularmatrices/#SpeedyWeather.LowerTriangularMatrices.LowerTriangularMatrix","page":"Submodule: LowerTriangularMatrices","title":"SpeedyWeather.LowerTriangularMatrices.LowerTriangularMatrix","text":"L = LowerTriangularMatrix{T}(v::Vector{T},m::Int,n::Int)\n\nA lower triangular matrix implementation that only stores the non-zero entries explicitly. L<:AbstractMatrix although in general we have L[i] != Matrix(L)[i], the former skips zero entries, tha latter includes them.\n\n\n\n\n\n","category":"type"},{"location":"lowertriangularmatrices/#SpeedyWeather.LowerTriangularMatrices.ij2k","page":"Submodule: LowerTriangularMatrices","title":"SpeedyWeather.LowerTriangularMatrices.ij2k","text":"k = ij2k(   i::Integer,     # row index of matrix\n            j::Integer,     # column index of matrix\n            m::Integer)     # number of rows in matrix\n\nConverts the index pair i,j of an mxn LowerTriangularMatrix L to a single index k that indexes the same element in the corresponding vector that stores only the lower triangle (the non-zero entries) of L.\n\n\n\n\n\n","category":"function"},{"location":"lowertriangularmatrices/#Base.fill!-Union{Tuple{T}, Tuple{LowerTriangularMatrix{T}, Any}} where T","page":"Submodule: LowerTriangularMatrices","title":"Base.fill!","text":"fill!(L::LowerTriangularMatrix,x)\n\nFills the elements of L with x. Faster than fill!(::AbstractArray,x) as only the non-zero elements in L are assigned with x.\n\n\n\n\n\n","category":"method"},{"location":"lowertriangularmatrices/#SpeedyWeather.LowerTriangularMatrices.eachharmonic","page":"Submodule: LowerTriangularMatrices","title":"SpeedyWeather.LowerTriangularMatrices.eachharmonic","text":"unit_range = eachharmonic(L::LowerTriangular)\n\ncreates unit_range::UnitRange to loop over all non-zeros in a LowerTriangularMatrix L. Like eachindex but skips the upper triangle with zeros in L.\n\n\n\n\n\nunit_range = eachharmonic(Ls::LowerTriangularMatrix...)\n\ncreates unit_range::UnitRange to loop over all non-zeros in the LowerTriangularMatrices provided as arguments. Checks bounds first. All LowerTriangularMatrix's need to be of the same size. Like eachindex but skips the upper triangle with zeros in L.\n\n\n\n\n\n","category":"function"},{"location":"conventions/#Style-and-convention-guide","page":"Style and convention guide","title":"Style and convention guide","text":"","category":"section"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"In SpeedyWeather.jl we've been following the several conventions that are documented here.","category":"page"},{"location":"conventions/#Variable-naming","page":"Style and convention guide","title":"Variable naming","text":"","category":"section"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"The prognostic variables in spectral space are called","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"    vor         # Vorticity of horizontal wind field\n    div         # Divergence of horizontal wind field\n    temp        # Absolute temperature [K]\n    pres_surf   # Logarithm of surface pressure [log(Pa)]\n    humid       # Specific humidity [g/kg]","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"their transforms into grid-point space get a _grid suffix, their tendencies a _tend suffix. Further derived diagnostic dynamic variables are","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"    u\n    v\n    geopot\n    ...","category":"page"},{"location":"conventions/#Preallocation","page":"Style and convention guide","title":"Preallocation","text":"","category":"section"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"All arrays representing variables are preallocated and grouped into two structs","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"    Prog::PrognosticVariables\n    Diag::DiagnosticVariables","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"The Diag struct contains further structs which represent the grid-point transformations of the prognostic variables and their tendencies.","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"    gridvars::GridVariables\n    tendencies::Tendencies\n    ...","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Constant arrays are grouped into several structs","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Boundaries","category":"page"},{"location":"conventions/#Julian-conventions","page":"Style and convention guide","title":"Julian conventions","text":"","category":"section"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"We follow Julia's style guide and highlight here some important aspects of it.","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Bang (!) convention. A function func does not change its input arguments, however, func! does.","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Hence, func! is often the in-place version of func, avoiding as much memory allocation as possible and often changing its first argument, e.g. func!(out,in) so that argument in is used to calculate out which has been preallocated before function call.","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"Number format flexibility. Numeric literals such as 2.0 or 1/3 are only used in the model setup","category":"page"},{"location":"conventions/","page":"Style and convention guide","title":"Style and convention guide","text":"but avoided throughout the code to obtain a fully number format-flexible package using the number format NF as a compile-time variable throughout the code. This often leads to overly specific code whereas a Real would generally suffice. However, this is done to avoid any implicit type conversions.","category":"page"},{"location":"extending/#New-model-setups","page":"Extending SpeedyWeather","title":"New model setups","text":"","category":"section"},{"location":"extending/","page":"Extending SpeedyWeather","title":"Extending SpeedyWeather","text":"more to come...","category":"page"},{"location":"dynamical_core/#Dynamical-core","page":"Dynamical core","title":"Dynamical core","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"A mathematical and implementation-specific description of the dynamical core used in SpeedyWeather.jl. We start by describing the barotropic vorticity equations which is one set of equations that SpeedyWeather.jl can solve (see How to run SpeedyWeather.jl) as many details therein also apply to the Shallow water equations and Primitive equations explained thereafter.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"The dynamical core presented here largely follows the idealized models with spectral dynamics developed at the Geophysical Fluid Dynamics Laboratory[1]: A barotropic vorticity model[2], a shallow water model [3] and a primitive equation model[4]. ","category":"page"},{"location":"dynamical_core/#Barotropic-vorticity-equation","page":"Dynamical core","title":"Barotropic vorticity equation","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"The barotropic vorticity equation is the prognostic equation that describes the time evolution of relative vorticity zeta with advection, Coriolis force and diffusion in a single global layer on the sphere.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"fracpartial zetapartial t + nabla cdot (mathbfu(zeta + f)) =\nnabla times mathbfF + (-1)^n+1nunabla^2nzeta","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"with time t, velocity vector mathbfu = (u v), Coriolis parameter f, and hyperdiffusion (-1)^n+1 nu nabla^2n zeta (n is the hyperdiffusion order; see Horizontal diffusion). We also include a forcing vector mathbfF = (F_uF_v) which acts on the zonal velocity u and the meridional velocity v and hence its curl nabla times mathbfF is a tendency for relative vorticity zeta.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Starting with some relative vorticity zeta, the Laplacian is inverted to obtain the stream function Psi","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Psi = nabla^-2zeta","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"The zonal velocity u and meridional velocity v are then the (negative) meridional gradient and zonal gradient of Psi","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"beginaligned\nu = -frac1R fracpartial Psipartial theta \nv = frac1Rcos(theta) fracpartial Psipartial phi \nendaligned","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"which is described in Derivatives in spherical coordinates.","category":"page"},{"location":"dynamical_core/#Algorithm","page":"Dynamical core","title":"Algorithm","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"We briefly outline the algorithm that SpeedyWeather.jl uses in order to integrate the barotropic vorticity equation. As an initial step","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"0. Start with initial conditions of zeta_lm in spectral space and transform this model state to grid-point space:","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Invert the Laplacian to obtain the stream function Psi_lm in spectral space\nobtain zonal velocity (cos(theta)u)_lm through a Meridional derivative\nobtain meridional velocity (cos(theta)v)_lm through a Zonal derivative\nTransform zonal and meridional velocity (cos(theta)u)_lm, (cos(theta)v)_lm to grid-point space\nUnscale the cos(theta) factor to obtain uv\nTransform zeta_lm to zeta in grid-point space","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Now loop over","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Compute the forcing vector mathbfF = (F_uF_v) for u and v\nMultiply uv with zeta+f in grid-point space\nAdd A = F_u + v(zeta + f) and B = F_v - u(zeta + f)\nTransform these vector components to spectral space A_lm, B_lm\nCompute the curl of (AB)_lm in spectral space which is the tendency of zeta_lm\nCompute the Horizontal diffusion based on that tendency\nCompute a leapfrog time step as described in Time integration\nTransform the spectral state of zeta_lm to grid-point uvzeta as described in 0.\nPossibly do some output\nRepeat from 1.","category":"page"},{"location":"dynamical_core/#Shallow-water-equations","page":"Dynamical core","title":"Shallow water equations","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"beginaligned\nfracpartial zetapartial t + nabla cdot (mathbfu(zeta + f)) = (-1)^n+1nunabla^2nzeta \nfracpartial mathcalDpartial t - nabla times (mathbfu(zeta + f)) = -nabla^2(tfrac12(u^2 + v^2) + geta) + (-1)^n+1nunabla^2nmathcalD \nfracpartial etapartial t + nabla cdot (mathbfuh) = 0\nendaligned","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"where zeta = hatmathbfz cdot (nabla times mathbfu) is the relative vorticity, mathcalD = nabla cdot mathbfu the divergence, and eta the deviation from the fluid's rest height.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Note: more to come...","category":"page"},{"location":"dynamical_core/#Primitive-equations","page":"Dynamical core","title":"Primitive equations","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"The primitive equations solved by SpeedyWeather.jl are","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"beginaligned\npartial_t u =  \npartial_t v =  \npartial_t T =   \npartial_t Q = \nendaligned","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Note: more to come...","category":"page"},{"location":"dynamical_core/#Horizontal-diffusion","page":"Dynamical core","title":"Horizontal diffusion","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"In SpeedyWeather.jl we use hyerdiffusion through an n-th power Laplacian (-1)^n+1nabla^2n (hyper when n1) which can be implemented as a multiplication of the spectral coefficients Psi_lm with (-l(l+1))^nR^-2n (see spectral Laplacian) It is therefore computationally not more expensive to apply hyperdiffusion over diffusion as the (-l(l+1))^nR^-2n can be precomputed. Note the sign change (-1)^n+1 here is such that the dissipative nature of the diffusion operator is retained for n odd and even.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"In SpeedyWeather.jl the diffusion is applied implicitly. For that, consider a leapfrog scheme with time step Delta t of variable zeta to obtain from time steps i-1 and i, the next time step i+1","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_i+1 = zeta_i-1 + 2Delta t dzeta","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"with dzeta being some tendency evaluated from zeta_i. Now we want to add a diffusion term (-1)^n+1nu nabla^2nzeta with viscosity nu, wich however, is implicitly calculated from zeta_i+1, then","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_i+1 = zeta_i-1 + 2Delta t (dzeta + (-1)^n+1 nunabla^2nzeta_i+1)","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"As the application of (-1)^n+1nunabla^2n is, for every spectral mode, equivalent to a multiplication of a constant, we can rewrite this to","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_i+1 = fraczeta_i-1 + 2Delta t dzeta1 - 2Delta (-1)^n+1nunabla^2n","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"and expand the numerator to","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"zeta_i+1 = zeta_i-1 + 2Delta t fracdzeta + (-1)^n+1 nunabla^2nzeta_i-11 - 2Delta t (-1)^n+1nu nabla^2n","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Hence the diffusion can be applied implicitly by updating the tendency dzeta as","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"dzeta to fracdzeta + (-1)^n+1nunabla^2nzeta_i-11 - 2Delta t nu nabla^2n","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"which only depends on zeta_i-1. Now let D_textexplicit = (-1)^n+1nunabla^2n be the explicit part and D_textimplicit = 1 - (-1)^n+1 2Delta t nunabla^2n the implicit part. Both parts can be precomputed and are D_textimplicit = 1 - 2Delta t nunabla^2n the implicit part. Both parts can be precomputed and are only an element-wise multiplication in spectral space. For every spectral harmonic lm we do","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"dzeta to D_textimplicit^-1(dzeta + D_textexplicitzeta_i-1)","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Hence 2 multiplications and 1 subtraction with precomputed constants. However, we will normalize the (hyper-)Laplacians as described in the following. This also will take care of the alternating sign such that the diffusion operation is dissipative regardless the power n.","category":"page"},{"location":"dynamical_core/#Normalization-of-diffusion","page":"Dynamical core","title":"Normalization of diffusion","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"In physics, the Laplace operator nabla^2 is often used to represent diffusion due to viscosity in a fluid. In that case, the viscosity coefficient is nu of units textm^2texts^-1 and the full operator reads as nu nabla^2 with units (textm^2texts^-1)(textm^-2) = texts^-1. This motivates us to normalize the Laplace operator by a constant of units textm^-2 and the viscosity coefficient by its inverse such that the viscosity coefficient becomes a damping timescale of unit texts^-1. Given the application in spectral space we decide to normalize by the largest eigenvalue -l_textmax(l_textmax+1) such that all entries in the discrete spectral Laplace operator are in 01. This also has the effect that the alternating sign drops out, such that higher wavenumbers are always dampened and not amplified. The normalized viscosity coefficient nu^* = l_textmax(l_textmax+1)nu (always positive) is therefore reinterpreted as the (inverse) time scale at which the highest wavenumber is dampened to zero due to diffusion. Together we have ","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"D^textexplicit_lm = -nu^* fracl(l+1)l_textmax(l_textmax+1)","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"and the hyper-Laplacian of power n follows as","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"D^textexplicitn_lm = -nu^* left(fracl(l+1)l_textmax(l_textmax+1)right)^n","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"and the implicit part is accordingly D^textimplicitn_lm = 1 - 2Delta t D^textexplicitn_lm.","category":"page"},{"location":"dynamical_core/#Radius-scaling","page":"Dynamical core","title":"Radius scaling","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"SpeedyWeather.jl uses a scaling for vorticity zeta and stream function Psi that is","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"tildezeta = zeta R tildePsi = Psi R^-1","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"In the barotropic vorticity equation model the inversion of the Laplacians in order to obtain Psi from zeta therefore becomes","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"tildezeta = tildenabla^2 tildePsi","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"where the dimensionless gradients simply omit the scaling with 1R, tildenabla = Rnabla. The Barotropic vorticity equation scaled with R^2 is","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"partial_tildettildezeta + tildenabla cdot (mathbfu(tildezeta + tildef)) = tildenutildenabla^2ntildezeta","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"with","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"tildet = tR^-1, the scaled time t\nmathbfu = (uv), the velocity vector (no scaling applied)\ntildef = fR, the scaled Coriolis parameter f\ntildenu = nu^* R, the scaled viscosity nu^*, which itself is normalized to a damping time scale, see Normalization of diffusion.","category":"page"},{"location":"dynamical_core/#Scaled-shallow-water-equations","page":"Dynamical core","title":"Scaled shallow water equations","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"Similar to the scaled barotropic vorticity equations, the scaled shallow water equations scale the vorticity and the divergence equation with R^2, but the continuity equation with R","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"beginaligned\nfracpartial tildezetapartial tildet + tildenabla cdot (mathbfu(tildezeta + tildef)) =\ntildenutildenabla^2ntildezeta \nfracpartial tildemathcalDpartial tildet - tildenabla times (mathbfu(tildezeta + tildef)) =\n-tildenabla^2left(tfrac12(u^2 + v^2) + geta right) + tildenutildenabla^2ntildemathcalD \nfracpartial etapartial tildet + tildenabla cdot (mathbfuh) = 0\nendaligned","category":"page"},{"location":"dynamical_core/#Time-integration","page":"Dynamical core","title":"Time integration","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"SpeedyWeather.jl uses a leapfrog time scheme with a Robert's and William's filter to dampen the computational mode and achieve 3rd order accuracy.","category":"page"},{"location":"dynamical_core/#Oscillation-equation","page":"Dynamical core","title":"Oscillation equation","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"fracdFdt = iomega F","category":"page"},{"location":"dynamical_core/#References","page":"Dynamical core","title":"References","text":"","category":"section"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"[1]: Geophysical Fluid Dynamics Laboratory, Idealized models with spectral dynamics","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"[2]: Geophysical Fluid Dynamics Laboratory, The barotropic vorticity equation.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"[3]: Geophysical Fluid Dynamics Laboratory, The Shallow Water Equations.","category":"page"},{"location":"dynamical_core/","page":"Dynamical core","title":"Dynamical core","text":"[4]: Geophysical Fluid Dynamics Laboratory, The Spectral Dynamical Core","category":"page"},{"location":"spectral_transform/#Spherical-Harmonic-Transform","page":"Spherical harmonic transform","title":"Spherical Harmonic Transform","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The following sections outline the implementation of the spherical harmonic transform (in short spectral transform) between the coefficients of the spherical harmonics (the spectral space) and the grid space on a longitude-latitude regular Gaussian grid.","category":"page"},{"location":"spectral_transform/#Inspiration","page":"Spherical harmonic transform","title":"Inspiration","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The spectral transform implemented by SpeedyWeather.jl follows largely Justin Willmert's CMB.jl package and makes use of AssociatedLegendrePolynomials.jl and FFTW.jl (for Float32/64) or GenericFFT.jl (for generic) for the Fourier transform. Justin described his work in a Blog series [1][2][3][4][5][6][7][8].","category":"page"},{"location":"spectral_transform/#Spherical-harmonics","page":"Spherical harmonic transform","title":"Spherical harmonics","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The spherical harmonics Y_lm of degree l and order m over the longitude phi = (02pi) and colatitudes theta = (-pi2pi2), are","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Y_lm(phi theta) = lambda_l^m(sintheta) e^imphi","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"with lambda_l^m being the pre-normalized associated Legendre polynomials, and e^imphi are the complex exponentials (the Fourier modes). Together they form a set of orthogonal basis functions on the sphere. For an interactive visualisation of the spherical harmonics, see here.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"info: Latitudes versus colatitudes\nThe implementations of the spherical transforms in SpeedyWeather.jl use colatitudes theta = (0pi) (0 at the north pole) but the dynamical core uses latitudes theta = (-pi2pi2) (pi2 at the north pole). However, all arrays are always sorted north to south such that [i,1] will access the northern-most grid points. Note: We may also use latitudes in the spherical harmonic transform in the future for consistency. ","category":"page"},{"location":"spectral_transform/#Synthesis-(spectral-to-grid)","page":"Spherical harmonic transform","title":"Synthesis (spectral to grid)","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The synthesis (or inverse transform) takes the spectral coefficients a_lm and transforms them to grid-point values f(phitheta) (for the sake of simplicity first regarded as continuous). The synthesis is a linear combination of the spherical harmonics Y_lm with non-zero coefficients.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"f(phitheta) = sum_l=0^infty sum_m=-l^l a_lm Y_lm(phitheta)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"We obtain an approximation with a finite set of a_lm by truncating the series after l = l_max.","category":"page"},{"location":"spectral_transform/#Analysis-(grid-to-spectral)","page":"Spherical harmonic transform","title":"Analysis (grid to spectral)","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Starting in grid-point space we can transform a field f(lambdatheta) into the spectral space of the spherical harmonics by","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"a_lm = int_0^2pi int_-tfracpi2^tfracpi2 f(lambdatheta) Y_lm(lambdatheta) cos theta dtheta dlambda","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"This integral has to be discretized to when grid-point values f(lambda_itheta_i) are used. For more details, see [7],[8].","category":"page"},{"location":"spectral_transform/#Spectral-packing","page":"Spherical harmonic transform","title":"Spectral packing","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Spectral packing is the way how the coefficients a_lm of the spherical harmonics of a given spectral field are stored in an array. SpeedyWeather.jl uses the conventional spectral packing of degree l and order m as illustrated in the following image (Cyp, CC BY-SA 3.0, via Wikimedia Commons)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"<img src=\"https://upload.wikimedia.org/wikipedia/commons/1/12/Rotating_spherical_harmonics.gif\">","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Every row represents an order l geq 0, starting from l=0 at the top. Every column represents an order m geq 0, starting from m=0 on the left. The coefficients of these spherical harmonics are directly mapped into a matrix a_lm as ","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":" m   \nl a_00   \n a_10 a_11  \n a_20 a_12 a_22 \n a_30 a_13 a_23 a_33","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"which is consistently extended for higher degrees and orders. Consequently, all spectral fields are lower-triangular matrices with complex entries. The upper triangle excluding the diagonal explicitly stores zeros. Note that internally vector fields include an additional degree, such that l_max = m_max + 1 (see Gradients in spherical coordinates for more information). The harmonics with a_l0 (the first column) are also called zonal harmonics as they are constant with longitude phi. The harmonics with a_ll (the main diagonal) are also called sectoral harmonics as they essentially split the sphere into 2l sectors in longitude phi without a zero-crossing in latitude.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"info: Array indices\nFor a spectral field alms note that due to Julia's 1-based indexing the coefficient a_lm is obtained via alms[l+1,m+1].","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Fortran speedy does not use the same spectral packing as SpeedyWeather.jl. The alternative packing lm therein uses l=m and m=l-m as summarized in the following table.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"degree l order m l=m m=l-m\n0 0 0 0\n1 0 0 1\n1 1 1 0\n2 0 0 2\n2 1 1 1\n2 2 2 0\n3 0 0 3\n... ... ... ...","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"This alternative packing uses the top-left triangle of a coefficient matrix, and the degrees and orders from above are stored at the following indices","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":" m   \nl a_00 a_10 a_20 a_30\n a_11 a_21 a_31 \n a_22 a_32  \n a_33   ","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"This spectral packing is not used in SpeedyWeather.jl but illustrated here for completeness and comparison with Fortran-speedy.","category":"page"},{"location":"spectral_transform/#Example-transforms","page":"Spherical harmonic transform","title":"Example transforms","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"julia> using SpeedyWeather\njulia> alms = zeros(ComplexF64,3,3)    # spectral coefficients\njulia> alms[2,2] = 1                   # only l=1,m=1 harmonic\njulia> map = gridded(alms)             # convert to grid space\n8×4 Matrix{Float64}:\n -0.324541  -0.600363  -0.600363  -0.324541\n -0.134429  -0.248678  -0.248678  -0.134429\n  0.134429   0.248678   0.248678   0.134429\n  0.324541   0.600363   0.600363   0.324541\n  0.324541   0.600363   0.600363   0.324541\n  0.134429   0.248678   0.248678   0.134429\n -0.134429  -0.248678  -0.248678  -0.134429\n -0.324541  -0.600363  -0.600363  -0.324541\n \njulia> spectral(map)                   # back to spectral space\n3×3 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im          0.0+0.0im\n 0.0+0.0im  1.0+3.60727e-17im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im          0.0+0.0im","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"and we have successfully reobtained the l=m=1 spherical harmonic.","category":"page"},{"location":"spectral_transform/#Available-horizontal-resolutions","page":"Spherical harmonic transform","title":"Available horizontal resolutions","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"SpeedyWeather.jl uses triangular truncation such that only spherical harmonics with l leq l_max and m leq m_max are explicitly represented. This is usually described as Tm_max, with l_max = m_max (although in vector quantities require one more degree l in the recursion relation of meridional gradients). For example, T31 is the spectral resolution with l_max = m_max = 31. Note that the degree l and order m are mathematically 0-based, such that the corresponding coefficient matrix is of size 32x32.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Using triangular truncation[9], there are constraints on the corresponding grid resolution. Let nlon, nlat be the number of longitudes, latitudes on a regular Gaussian grid. Then spectral and grid resolution have to be chosen such that","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"nlon geq 3l_max+1\nnlat geq (3l_max+1)2","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"In general, we choose nlon = 2nlat, and ideally nlon is easily Fourier-transformable, e.g. nlon = 2^i3^j5^k with some integers ijk geq 0. SpeedyWeather.jl is tested at the following horizontal resolutions, with Delta x = tfrac2pi Rnlon as the approximate grid spacing at the Equator","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"l_max nlon nlat Delta x\n31 (default) 96 48 400 km\n42 128 64 300 km\n85 256 128 160 km\n170 512 256 80 km\n341 1024 512 40 km\n682 2048 1024 20 km","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Choosing trunc as argument in run_speedy will automatically choose nlon,nlat as presented in the table. Other common choices are T63 (192x96), T127 (384x192), T255 (768x384), T511 (1536x768), among others.","category":"page"},{"location":"spectral_transform/#Derivatives-in-spherical-coordinates","page":"Spherical harmonic transform","title":"Derivatives in spherical coordinates","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Horizontal gradients in spherical coordinates are defined for a scalar field A and the latitudes theta and longitudes lambda as","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"nabla A = left(frac1Rcosthetafracpartial Apartial lambda frac1Rfracpartial Apartial theta right)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"However, the divergence of a vector field mathbfu = (uv) includes additional cos(theta) scalings","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"nabla cdot mathbfu = frac1Rcosthetafracpartial upartial lambda +\nfrac1Rcosthetafracpartial (v costheta)partial theta","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"and similar for the curl","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"nabla times mathbfu = frac1Rcosthetafracpartial vpartial lambda -\nfrac1Rcosthetafracpartial (u costheta)partial theta","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The radius of the sphere (i.e. Earth) is R. The zonal gradient scales with 1cos(theta) as the  longitudes converge towards the poles (note that theta describes latitudes here, definitions using colatitudes replace the cos with a sin.)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Starting with a spectral field of vorticity zeta and divergence mathcalD one can obtain stream function Psi and velocity potential Phi by inverting the Laplace operator nabla^2:","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Psi = nabla^-2zeta quad Phi = nabla^-2mathcalD","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The velocities uv are then obtained from (uv) = nabla^botPsi + nablaPhi following the definition from above and nabla^bot = (-R^-1partial_theta (Rcostheta)^-1partial_lambda)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"beginaligned\nu = -frac1Rpartial_thetaPsi + frac1Rcosthetapartial_lambdaPhi \nv = +frac1Rpartial_thetaPhi + frac1Rcosthetapartial_lambdaPsi\nendaligned","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Alternatively, we can use the velocities U = ucostheta V = vcostheta, which we do as the meridional gradient for spherical harmonics is easier implemented with a costheta-scaling included, and because the divergence and  curl in spherical coordinates evaluates the meridional gradient with UV and not uv. From uv we can return to zeta mathcalD via","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"beginaligned\nzeta = frac1Rcosthetapartial_lambda v - frac1Rcosthetapartial_theta (u costheta) \nmathcalD = frac1Rcosthetapartial_lambda u + frac1Rcosthetapartial_theta (v costheta)\nendaligned","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Equivalently, we have","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"beginaligned\nU = -fraccosthetaRpartial_thetaPsi + frac1Rpartial_lambdaPhi \nV = +fraccosthetaRpartial_thetaPhi + frac1Rpartial_lambdaPsi \nzeta = frac1Rpartial_lambda left( fracVcos^2theta right) -\nfraccosthetaRpartial_theta left( fracUcos^2theta right) \nmathcalD = frac1Rpartial_lambda left( fracUcos^2theta right) +\nfraccosthetaRpartial_theta left( fracVcos^2theta right)\nendaligned","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"which is a more convenient formulation as required costheta scalings are reduced to a minimum. The remaining (UV)*cos^-2theta are done in grid-point space and usually in combination with other operations like the computation of the vorticity flux. But also note that SpeedyWeather.jl scales the equations with the radius R (see Radius scaling) such that the divisions by R drop out too. As described in Meridional derivative, it is more convenient to implement costheta partial_theta via a recursion relation for the Legendre polynomials than partial_theta directly. How the operators nabla nabla times nabla cdot can be implemented with spherical harmonics is presented in the following sections.","category":"page"},{"location":"spectral_transform/#Zonal-derivative","page":"Spherical harmonic transform","title":"Zonal derivative","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The zonal derivative of a scalar field Psi in spectral space is the zonal derivative of all its respective spherical harmonics Psi_lm(phitheta) (now we use phi for longitudes to avoid confusion with the Legendre polynomials lambda_lm)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"v_lm = frac1R cos(theta) fracpartialpartial phi left( lambda_l^m(costheta) e^imphi right) =\nfracimR cos(theta) lambda_l^m(costheta) e^imphi = fracimR cos(theta) Psi_lm","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"So for every spectral harmonic, cos(theta)v_lm is obtained from Psi_lm via a multiplication with imR. Unscaling the cos(theta)-factor is done after transforming the spectral coefficients v_lm into grid-point space. As discussed in Radius scaling, SpeedyWeather.jl scales the stream function as tildePsi = R^-1Psi such that the division by radius R in the gradients can be omitted. The zonal derivative becomes therefore effectively for each spherical harmonic a scaling with its (imaginary) order im. The spherical harmonics are essentially just a Fourier transform in zonal direction and the derivative a multiplication with the respective wave number m times imaginary i.","category":"page"},{"location":"spectral_transform/#Meridional-derivative","page":"Spherical harmonic transform","title":"Meridional derivative","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The meridional derivative of the spherical harmonics is a derivative of the Legendre polynomials for which the following recursion relation applies[10],[11]","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"costheta fracdP_lmdtheta = -lepsilon_l+1mP_l+1m + (l+1)epsilon_lmP_l-1m","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"with recursion factors","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"epsilon_lm = sqrtfracl^2-m^24l^2-1","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"In the following we use the example of obtaining the zonal velocity u from the stream function Psi, which is through the negative meridional gradient. For the meridional derivative itself the leading minus sign has to be omitted. Starting with the spectral expansion","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Psi(lambdatheta) = sum_lmPsi_lmP_lm(sintheta)e^imlambda","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"we multiply with -R^-1costhetapartial_theta to obtain","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"costhetaleft(-frac1Rpartial_thetaPsi right) = -frac1Rsum_lmPsi_lme^imlambdacosthetapartial_theta P_lm","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"at which point the recursion from above can be applied. Collecting terms proportional to P_lm then yields","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"(cos(theta)u)_lm = -frac1R(-(l-1)epsilon_lmPsi_l-1m + (l+2)epsilon_l+1mPsi_l+1m)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"To obtain the coefficient of each spherical harmonic lm of the meridional gradient of a spectral field, two  coefficients at l-1m and l+1m have to be combined. This means that the coefficient of a gradient ((costheta) u)_lm is a linear combination of the coefficients of one higher and one lower degree Psi_l+1mPsi_l-1m. As the coefficient Psi_lm with ml are zero, the sectoral harmonics (l=m) of the gradients are obtained from the first off-diagonal only. However, the l=l_max harmonics of the gradients require the l_max-1 as well as the l_max+1 harmonics. In SpeedyWeather.jl vector quantities like uv use therefore one more meridional mode than scalar quantities such as vorticity zeta or stream function Psi. The meridional derivative in SpeedyWeather.jl also omits the 1R-scaling as explained for the Zonal derivative and in Radius scaling.","category":"page"},{"location":"spectral_transform/#Divergence-and-curl-in-spherical-harmonics","page":"Spherical harmonic transform","title":"Divergence and curl in spherical harmonics","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The meridional gradient as described above can be applied to scalars, such as Psi and Phi in the conversion to velocities (uv) = nabla^botPsi + nablaPhi, however, the operators curl nabla times and divergence nabla cdot in spherical coordinates involve a costheta scaling before the meridional gradient is applied. How to translate this to spectral coefficients has to be derived separately[10],[11].","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The spectral transform of vorticity zeta is","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"zeta_lm = frac12piint_-tfracpi2^tfracpi2int_0^2pi zeta(lambdatheta) P_lm(sintheta) e^imlambda dlambda costheta dtheta","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Given that Rzeta = cos^-1partial_lambda v - cos^-1partial_theta (u costheta), we therefore have to evaluate a meridional integral of the form","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"int P_lm frac1cos theta partial_theta(u costheta)) cos theta dtheta","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"which can be solved through integration by parts. As ucostheta = 0 at theta = pm tfracpi2 only the integral","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"= -int partial_theta P_lm (u costheta) dtheta = -int costheta partial_theta P_lm (fracucostheta) costheta dtheta","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"remains. Inserting the recurrence relation from the Meridional derivative turns this into","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"= -int left(-l epsilon_l+1mP_l+1m + (l+1)epsilon_lm P_l-1m right) (fracucostheta) cos theta dtheta","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"Now we expand (tfracucostheta) but only the lm harmonic will project ontoP_lm. Let u^* = ucos^-1theta v^* = vcos^-1theta we then have in total","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"beginaligned\nRzeta_lm = imv^*_lm + (l+1)epsilon_lmu^*_l-1m - lepsilon_l+1mu^*_l+1m \nRD_lm = imu^*_lm - (l+1)epsilon_lmv^*_l-1m + lepsilon_l+1mv^*_l+1m \nendaligned","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"And the divergence D is similar, but (uv) to (-vu). We have moved the scaling with the radius R directly into zetaD as further described in Radius scaling.","category":"page"},{"location":"spectral_transform/#Laplacian","page":"Spherical harmonic transform","title":"Laplacian","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"The spectral Laplacian is easily applied to the coefficients Psi_lm of a spectral field as the spherical harmonics are eigenfunctions of the Laplace operator nabla^2 in spherical coordinates with eigenvalues -l(l+1) divided by the radius squared R^2, i.e. nabla^2 Psi becomes tfrac-l(l+1)R^2Psi_lm in spectral space. For example, vorticity zeta and streamfunction Psi are related by zeta = nabla^2Psi in the barotropic vorticity model. Hence, in spectral space this is equivalent for every spectral mode of degree l and order m to","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"zeta_lm = frac-l(l+1)R^2Psi_lm","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"This can be easily inverted to obtain the stream function Psi from vorticity zeta instead. In order to avoid division by zero, we set Psi_00 here, given that the stream function is only defined up to a constant anyway.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"beginaligned\nPsi_lm = fracR^2-l(l+1)zeta_lm quad foralllm  0\nPsi_00 = 0\nendaligned","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"See also Horizontal diffusion and Normalization of diffusion.","category":"page"},{"location":"spectral_transform/#U,V-from-vorticity-and-divergence","page":"Spherical harmonic transform","title":"U,V from vorticity and divergence","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"After having discussed the zonal and meridional derivatives with spherical harmonics as well as the Laplace operator, we can derive the conversion from vorticity zeta and divergence D (which are prognostic variables) to U=ucostheta V=vcostheta. Both are linear operations that act either solely on a given harmonic (the zonal gradient and the Laplace operator) or are linear combinations between one lower and one higher degree l (the meridional gradient). It is therefore computationally more efficient to compute UV directly from zetaD instead of calculating stream function and velocity potential first. In total we have","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"beginaligned\nU_lm = -fraciml(l+1)(RD)_lm + fracepsilon_l+1ml+1(Rzeta)_l+1m - fracepsilon_lml(Rzeta)_l-1m \nV_lm = -fraciml(l+1)(Rzeta)_lm - fracepsilon_l+1ml+1(RD)_l+1m + fracepsilon_lml(RD)_l-1m \nendaligned","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"We have moved the scaling with the radius R directly into zetaD as further described in Radius scaling.","category":"page"},{"location":"spectral_transform/#References","page":"Spherical harmonic transform","title":"References","text":"","category":"section"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[1]: Justin Willmert, 2020. Introduction to Associated Legendre Polynomials (Legendre.jl Series, Part I)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[2]: Justin Willmert, 2020. Calculating Legendre Polynomials (Legendre.jl Series, Part II)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[3]: Justin Willmert, 2020. Pre-normalizing Legendre Polynomials (Legendre.jl Series, Part III)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[4]: Justin Willmert, 2020. Maintaining numerical accuracy in the Legendre recurrences (Legendre.jl Series, Part IV)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[5]: Justin Willmert, 2020. Introducing Legendre.jl (Legendre.jl Series, Part V)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[6]: Justin Willmert, 2020. Numerical Accuracy of the Spherical Harmonic Recurrence Coefficient (Legendre.jl Series Addendum)","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[7]: Justin Willmert, 2020. Notes on Calculating the Spherical Harmonics","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[8]: Justin Willmert, 2022. More Notes on Calculating the Spherical Harmonics: Analysis of maps to harmonic coefficients","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[9]: David Randall, 2021. An Introduction to Numerical Modeling of the Atmosphere, Chapter 22.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[10]: Dale Durran, 2010. Numerical Methods for Fluid Dynamics, Springer. In particular section 6.2, 6.4.","category":"page"},{"location":"spectral_transform/","page":"Spherical harmonic transform","title":"Spherical harmonic transform","text":"[11]: Geophysical Fluid Dynamics Laboratory, The barotropic vorticity equation.","category":"page"},{"location":"ringgrids/#RingGrids","page":"Submodule: RingGrids","title":"RingGrids","text":"","category":"section"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"RingGrids is a submodule that has been developed for SpeedyWeather.jl which is technically independent (SpeedyWeather.jl however imports it and so does SpeedyTransforms) and can also be used without running simulations. It is just not put into its own respective repository.","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"RingGrids defines several iso-latitude grids, which are mathematically described in the section on Grids. In brief, they include the regular latitude-longitude grids (here called FullClenshawGrid) as well as grids which latitudes are shifted to the Gaussian latitudes and reduced grids, meaning that they have a decreasing number of longitudinal points towards the poles to be more equal-area than full grids.","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"RingGrids defines and exports the following grids:","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"full grids: FullClenshawGrid, FullGaussianGrid, FullHEALPix, and FullOctaHEALPix\nreduced grids: OctahedralGaussianGrid, OctahedralClenshawGrid, OctaHEALPixGrid and HEALPixGrid","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"The following explanation of how to use these can be mostly applied to any of them, however, there are certain functions that are not defined, e.g. the full grids can be trivially converted to a Matrix but not the OctahedralGaussianGrid.","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"note: What is a ring?\nWe use the term ring, short for iso-latitude ring, to refer to a sequence of grid points that all share the same latitude. A latitude-longitude grid is a ring grid, as it organises its grid-points into rings. However, other grids, like the cubed-sphere are not based on iso-latitude rings. SpeedyWeather.jl only works with ring grids because its a requirement for the Spherical Harmonic Transform to be efficient. See Grids.","category":"page"},{"location":"ringgrids/#Creating-data-on-a-RingGrid","page":"Submodule: RingGrids","title":"Creating data on a RingGrid","text":"","category":"section"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"Every grid in RingGrids has a grid.data field, which is a vector containing the data on the grid. The grid points are unravelled west to east then north to south, meaning that it starts at 90˚N and 0˚E then walks eastward for 360˚ before jumping on the next latitude ring further south, this way circling around the sphere till reaching the south pole. This may also be called ring order.","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"Data in a Matrix which follows this ring order can be put on a FullGaussianGrid like so","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"using SpeedyWeather.RingGrids\nmap = randn(Float32,8,4)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"grid = FullGaussianGrid(map)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"A full Gaussian grid has always 2N x N grid points, but a FullClenshawGrid has 2N x N-1, if those dimensions don't match, the creation will throw an error. To reobtain the data from a grid, you can access its data field which returns a normal Vector","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"grid.data","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"Which can be reshaped to reobtain map from above. Alternatively you can Matrix(grid) to do this in one step","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"map == Matrix(FullGaussianGrid(map))","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"You can also use zeros,ones,rand,randn to create a grid, whereby nlat_half, i.e. the number of latitude rings on one hemisphere, Equator included, is used as a resolution parameter and here as a second argument.","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"nlat_half = 4\ngrid = randn(OctahedralGaussianGrid{Float16},nlat_half)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"and any element type T can be used for OctahedralGaussianGrid{T} and similar for other grid types.","category":"page"},{"location":"ringgrids/#Visualising-RingGrid-data","page":"Submodule: RingGrids","title":"Visualising RingGrid data","text":"","category":"section"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"As only the full grids can be reshaped into a matrix, the underlying data structure of any AbstractGrid is a vector. As shown in the examples above, one can therefore inspect the data as if it was a vector. But as that data has, through its <:AbstractGrid type, all the geometric information available to plot it on a map, RingGrids also exports plot function, based on UnicodePlots' heatmap.","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"nlat_half = 24\ngrid = randn(OctahedralGaussianGrid,nlat_half)\nplot(grid)","category":"page"},{"location":"ringgrids/#Indexing-RingGrids","page":"Submodule: RingGrids","title":"Indexing RingGrids","text":"","category":"section"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"All RingGrids have a single index ij which follows the ring order. While this is obviously not super exciting here are some examples how to make better use of the information that the data sits on a grid.","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"We obtain the latitudes of the rings of a grid by calling get_latd (get_lond is only defined for full grids, or use get_latdlonds for latitudes, longitudes per grid point not per ring)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"grid = randn(OctahedralClenshawGrid,5)\nlatd = get_latd(grid)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"Now we could calculate Coriolis and add it on the grid as follows","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"rotation = 7.29e-5                  # angular frequency of Earth's rotation [rad/s]\ncoriolis = 2rotation*sind.(latd)    # vector of coriolis parameters per latitude ring\n\nrings = eachring(grid)\nfor (j,ring) in enumerate(rings)\n    f = coriolis[j]\n    for ij in ring\n        grid[ij] += f\n    end\nend","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"eachring creates a vector of UnitRange indices, such that we can loop over the ring index j (j=1 being closest to the North pole) pull the coriolis parameter at that latitude and then loop over all in-ring indices i (changing longitudes) to do something on the grid. Something similar can be done to scale/unscale with the cosine of latitude for example. We can always loop over all grid-points like so","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"for ij in eachgridpoint(grid)\n    grid[ij]\nend","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"or use eachindex instead.","category":"page"},{"location":"ringgrids/#Interpolation-on-RingGrids","page":"Submodule: RingGrids","title":"Interpolation on RingGrids","text":"","category":"section"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"In most cases we will want to use RingGrids so that our data directly comes with the geometric information of where the grid-point is one the sphere. We have seen how to use get_latd, get_lond, ... for that above. This information generally can also be used to interpolate our data from grid to another or to request an interpolated value on some coordinates. Using our data on grid which is an OctahedralGaussianGrid from above we can use the interpolate function to get it onto a FullGaussianGrid (or any other grid for purpose)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"grid = randn(OctahedralGaussianGrid{Float32},4)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"interpolate(FullGaussianGrid,grid)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"By default this will linearly interpolate (it's an Anvil interpolator, see below) onto a grid with the same nlat_half, but we can also coarse-grain or fine-grain by specifying nlat_half directly as 2nd argument","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"interpolate(FullGaussianGrid,6,grid)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"So we got from an 8-ring OctahedralGaussianGrid{Float16} to a 12-ring FullGaussianGrid{Float64}, so it did a conversion from Float16 to Float64 on the fly too, because the default precision is Float64 unless specified. interpolate(FullGaussianGrid{Float16},6,grid) would have interpolated onto a grid with element type Float16.","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"One can also interpolate onto a give cordinate ˚N, ˚E like so","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"interpolate(30.0,10.0,grid)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"we interpolated the data from grid onto 30˚N, 10˚E. To do this simultaneously for many coordinates they can be packed into a vector too","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"interpolate([30.0,40.0,50.0],[10.0,10.0,10.0],grid)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"which returns the data on grid at 30˚N, 40˚N, 50˚N, and 10˚E respectively. Note how the interpolation here retains the element type of grid.","category":"page"},{"location":"ringgrids/#Performance-for-RingGrid-interpolation","page":"Submodule: RingGrids","title":"Performance for RingGrid interpolation","text":"","category":"section"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"Every time an interpolation like interpolate(30.0,10.0,grid) is called, several things happen, which are important to understand to know how to get the fastest interpolation out of this module in a given situation. Under the hood an interpolation takes three arguments","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"output vector\ninput grid\ninterpolator","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"The output vector is just an array into which the interpolated data is written, providing this prevents unnecessary allocation of memory in case the destination array of the interpolation already exists. The input grid contains the data which is subject to interpolation, it must come on a ring grid, however, its coordinate information is actually already in the interpolator. The interpolator knows about the geometry of the grid the data is coming on and the coordinates it is supposed to interpolate onto. It has therefore precalculated the indices that are needed to access the right data on the input grid and the weights it needs to apply in the actual interpolation operation. The only thing it does not know is the actual data values of that grid. So in the case you want to interpolate from grid A to grid B many times, you can just reuse the same interpolator. If you want to change the coordinates of the output grid but its total number of points remain constants then you can update the locator inside the interpolator and only else you will need to create a new interpolator. Let's look at this in practice. Say we have two grids an want to interpolate between them","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"grid_in = rand(HEALPixGrid,4)\ngrid_out = zeros(FullClenshawGrid,6)\ninterp = RingGrids.interpolator(grid_out,grid_in)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"Now we have created an interpolator interp which knows about the geometry where to interpolate from and the coordinates there to interpolate to. It is also initialized, meaning it has precomputed the indices to of grid_in that are supposed to be used. It just does not know about the data of grid_in (and neither of grid_out which will be overwritten anyway). We can now do","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"interpolate!(grid_out,grid_in,interp)\ngrid_out","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"which is identical to interpolate(grid_out,grid_in) but you can reuse interp for other data. The interpolation can also handle various element types (the interpolator interp does not have to be updated for this either)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"grid_out = zeros(FullClenshawGrid{Float16},6);\ninterpolate!(grid_out,grid_in,interp)\ngrid_out","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"and we have converted data from a HEALPixGrid{Float64} (Float64 is always default if not specified) to a FullClenshawGrid{Float16} including the type conversion Float64-Float16 on the fly. Technically there are three data types and their combinations possible: The input data will come with a type, the output array has an element type and the interpolator has precomputed weights with a given type. Say we want to go from Float16 data on an OctahedralGaussianGrid to Float16 on a FullClenshawGrid but using Float32 precision for the interpolation itself, we would do this by","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"grid_in = randn(OctahedralGaussianGrid{Float16},24)\ngrid_out = zeros(FullClenshawGrid{Float16},24)\ninterp = RingGrids.interpolator(Float32,grid_out,grid_in)\ninterpolate!(grid_out,grid_in,interp)\ngrid_out","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"As a last example we want to illustrate a situation where we would always want to interpolate onto 10 coordinates, but their locations may change. In order to avoid recreating an interpolator object we would do (AnvilInterpolator is described in Anvil interpolator)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"npoints = 10    # number of coordinates to interpolate onto\ninterp = AnvilInterpolator(Float32,HEALPixGrid,24,npoints)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"with the first argument being the number format used during interpolation, then the input grid type, its resolution in terms of nlat_half and then the number of points to interpolate onto. However, interp is not yet initialized as it does not know about the destination coordinates yet. Let's define them, but note that we already decided there's only 10 of them above.","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"latds = collect(0.0:5.0:45.0)\nlonds = collect(-10.0:2.0:8.0)\nnothing # hide","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"now we can update the locator inside our interpolator as follows","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"RingGrids.update_locator!(interp,latds,londs)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"With data matching the input from above, a nlat_half=24 HEALPixGrid, and allocate 10-element output vector","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"output_vec = zeros(10)\ngrid_input = rand(HEALPixGrid,24)\nnothing # hide","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"we can use the interpolator as follows","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"interpolate!(output_vec,grid_input,interp)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"which is the approximately the same as doing it directly without creating an interpolator first and updating its locator","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"interpolate(latds,londs,grid_input)","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"but allows for a reuse of the interpolator. Note that the two output arrays are not exactly identical because we manually set our interpolator interp to use Float32 for the interpolation whereas the default is Float64.","category":"page"},{"location":"ringgrids/#Anvil-interpolator","page":"Submodule: RingGrids","title":"Anvil interpolator","text":"","category":"section"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"Currently the only interpolator implemented is a 4-point bilinear interpolator, which schematically works as follows. Anvil interpolation is the bilinear average of a,b,c,d which are values at grid points in an anvil-shaped configuration at location x, which is denoted by Δab,Δcd,Δy, the fraction of distances between a-b,c-d, and ab-cd, respectively. Note that a,c and b,d do not necessarily share the same longitude/x-coordinate.","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"        0..............1    # fraction of distance Δab between a,b\n        |<  Δab   >|\n\n0^      a -------- o - b    # anvil-shaped average of a,b,c,d at location x\n.Δy                |\n.                  |\n.v                 x \n.                  |\n1         c ------ o ---- d\n\n          |<  Δcd >|\n          0...............1 # fraction of distance Δcd between c,d\n\n^ fraction of distance Δy between a-b and c-d.","category":"page"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"This interpolation is chosen as by definition of the ring grids, a and b share the same latitude, so do c and d, but the longitudes can be different for all four, a,b,c,d.","category":"page"},{"location":"ringgrids/#Function-index","page":"Submodule: RingGrids","title":"Function index","text":"","category":"section"},{"location":"ringgrids/","page":"Submodule: RingGrids","title":"Submodule: RingGrids","text":"RingGrids.each_index_in_ring\nRingGrids.eachgridpoint\nRingGrids.eachring\nRingGrids.whichring\nRingGrids.get_nlons","category":"page"},{"location":"ringgrids/#SpeedyWeather.RingGrids.each_index_in_ring","page":"Submodule: RingGrids","title":"SpeedyWeather.RingGrids.each_index_in_ring","text":"i = each_index_in_ring(grid,j)\n\nUnitRange i to access data on grid grid on ring j.\n\n\n\n\n\n","category":"function"},{"location":"ringgrids/#SpeedyWeather.RingGrids.eachgridpoint","page":"Submodule: RingGrids","title":"SpeedyWeather.RingGrids.eachgridpoint","text":"ijs = eachgridpoint(grid)\n\nUnitRange ijs to access each grid point on grid grid.\n\n\n\n\n\n","category":"function"},{"location":"ringgrids/#SpeedyWeather.RingGrids.eachring","page":"Submodule: RingGrids","title":"SpeedyWeather.RingGrids.eachring","text":"eachring(grid::SpeedyWeather.RingGrids.AbstractGrid) -> Any\n\n\nVector{UnitRange} rings to loop over every ring of grid grid and then each grid point per ring. To be used like\n\nrings = eachring(grid)\nfor ring in rings\n    for ij in ring\n        grid[ij]\n\n\n\n\n\neachring(\n    grid1::SpeedyWeather.RingGrids.AbstractGrid,\n    grids::Grid<:SpeedyWeather.RingGrids.AbstractGrid...\n) -> Any\n\n\nSame as eachring(grid) but performs a bounds check to assess that all grids in grids are of same size.\n\n\n\n\n\n","category":"function"},{"location":"ringgrids/#SpeedyWeather.RingGrids.whichring","page":"Submodule: RingGrids","title":"SpeedyWeather.RingGrids.whichring","text":"whichring(\n    ij::Integer,\n    rings::Vector{UnitRange{Int64}}\n) -> Int64\n\n\nObtain ring index j from gridpoint ij and Vector{UnitRange} describing rind indices as obtained from eachring(::Grid)\n\n\n\n\n\n","category":"function"},{"location":"ringgrids/#SpeedyWeather.RingGrids.get_nlons","page":"Submodule: RingGrids","title":"SpeedyWeather.RingGrids.get_nlons","text":"get_nlons(\n    Grid::Type{<:SpeedyWeather.RingGrids.AbstractGrid},\n    nlat_half::Integer;\n    both_hemispheres\n) -> Any\n\n\nReturns a vector nlons for the number of longitude points per latitude ring, north to south. Provide grid Grid and its resolution parameter nlat_half. For both_hemisphere==false only the northern hemisphere (incl Equator) is returned.\n\n\n\n\n\n","category":"function"},{"location":"#SpeedyWeather.jl-documentation","page":"Home","title":"SpeedyWeather.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for SpeedyWeather.jl a global atmospheric circulation model with simple parametrizations to represent physical processes such as clouds, precipitation and radiation.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpeedyWeather.jl is a global spectral model that uses a spherical harmonic transform to perform some calculations in spectral space (time integration, gradients, linear terms) and some in grid-point space (advection, non-linear terms, parameterizations). The prognostic variables used are vorticity, divergence, absolute temperature, logarithm of surface pressure and specific humidity. The time stepping uses a leapfrog scheme with additional filters and a semi-implicit formulation for gravity waves. The default resolution is T31 (96x48 grid points on a regular Gaussian grid, about 400km at the Equator) and 8 vertical levels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Simple parameterizations are used to represent the physical processes convection, large-scale condensation, clouds, short-wave radiation, long-waves radiation, surface fluxes of momentum and energy, and vertical diffusion.","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the following pages of the documentation for more details","category":"page"},{"location":"","page":"Home","title":"Home","text":"Installation\nHow to run SpeedyWeather.jl\nSpherical harmonic transform\nGrids\nDynamical core\nParametrizations\nExtending SpeedyWeather","category":"page"},{"location":"","page":"Home","title":"Home","text":"and the submodules","category":"page"},{"location":"","page":"Home","title":"Home","text":"RingGrids and their interpolation   \nLowerTriangularMatrices   \nSpeedyTransforms","category":"page"},{"location":"","page":"Home","title":"Home","text":"and the original documentation by Molteni and Kucharski.","category":"page"},{"location":"#Developers","page":"Home","title":"Developers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of  SpeedyWeather.jl is lead by Milan Klöwer and current and past contributors include","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tom Kimpson\nAlistair White\nMaximilian Gelbrecht\nDavid Meyer\nDaisuke Hotta\nNavid Constantinou","category":"page"},{"location":"","page":"Home","title":"Home","text":"Any contributions are always welcome!","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MK received funding by the European Research Council under Horizon 2020 within the ITHACA project, grant agreement number 741112 from 2021-2022. Since 2023 this project is also funded by the National Science Foundation NSF.","category":"page"},{"location":"time_integration/#Time-integration","page":"Time integration","title":"Time integration","text":"","category":"section"},{"location":"time_integration/","page":"Time integration","title":"Time integration","text":"SpeedyWeather.jl uses a leapfrog time scheme with a Robert's and William's filter to dampen the computational mode and achieve 3rd order accuracy.","category":"page"},{"location":"time_integration/#Oscillation-equation","page":"Time integration","title":"Oscillation equation","text":"","category":"section"},{"location":"time_integration/","page":"Time integration","title":"Time integration","text":"fracdFdt = iomega F","category":"page"},{"location":"time_integration/#Implementation-details","page":"Time integration","title":"Implementation details","text":"","category":"section"}]
}
